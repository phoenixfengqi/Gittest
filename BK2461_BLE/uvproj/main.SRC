; .\main.SRC generated from: ..\src\main.c
; COMPILER INVOKED BY:
;        C:\Keil_v5\C51\BIN\C51.EXE ..\src\main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\main.lst) TABS(2) SRC(.\main.SRC)

$NOMOD51

NAME	MAIN

CLK_EN_CFG	DATA	085H
P0	DATA	080H
P1	DATA	090H
P2	DATA	0A0H
P3	DATA	0B0H
T0	BIT	0B0H.4
AC	BIT	0D0H.6
P4	DATA	0B7H
T1	BIT	0B0H.5
T2	BIT	090H.0
EA	BIT	0A8H.7
P0_PU	DATA	0A9H
P1_PU	DATA	0AAH
P2_PU	DATA	0ABH
P3_PU	DATA	0ACH
P4_PU	DATA	0ADH
P0IN_EN	DATA	091H
PWM0_RESOL	DATA	0CEH
P1IN_EN	DATA	093H
PWM1_RESOL	DATA	0CFH
IE	DATA	0A8H
P2IN_EN	DATA	094H
P3IN_EN	DATA	095H
P4IN_EN	DATA	096H
FL	BIT	0D0H.1
INT_ADC	BIT	0C0H.6
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
P0_OPDR	DATA	0D8H
P1_OPDR	DATA	0D9H
EXSLEEP	DATA	0EAH
P2_OPDR	DATA	0DAH
IP	DATA	0B8H
P3_OPDR	DATA	0DBH
RI	BIT	098H.0
P4_OPDR	DATA	0DCH
INT0	BIT	0B0H.2
CY	BIT	0D0H.7
TI	BIT	098H.1
INT1	BIT	0B0H.3
INT2	BIT	090H.4
INT_LBD	BIT	0C0H.1
RXD0	BIT	0B0H.0
INT3	BIT	090H.5
RXD1	BIT	090H.2
INT4	BIT	090H.6
I2CM_TXRX_STS	DATA	0E5H
INT_PCA	BIT	0C0H.5
TXD0	BIT	0B0H.1
INT5	BIT	090H.7
P0_WUEN	DATA	0EBH
TXD1	BIT	090H.3
P1_WUEN	DATA	0ECH
RCAP2H	DATA	0CBH
P2_WUEN	DATA	0EDH
I2CM_CTRL	DATA	0E1H
SP	DATA	081H
T2EX	BIT	090H.1
P3_WUEN	DATA	0EEH
OV	BIT	0D0H.2
P4_WUEN	DATA	0EFH
INT_AES	BIT	0C0H.7
I2CS_TXRX_STS	DATA	0F5H
RCAP2L	DATA	0CAH
C_T2	BIT	0C8H.1
WR	BIT	0B0H.6
I2CS_CTRL	DATA	0F1H
RCLK	BIT	0C8H.5
ASADEN	DATA	0BBH
TCLK	BIT	0C8H.4
P00	BIT	080H.0
P10	BIT	090H.0
P01	BIT	080H.1
ASADDR	DATA	0BAH
PCON	DATA	087H
P20	BIT	0A0H.0
P11	BIT	090H.1
P02	BIT	080H.2
P30	BIT	0B0H.0
P21	BIT	0A0H.1
P12	BIT	090H.2
P03	BIT	080H.3
I2CM_TXRX_IE	DATA	0E7H
I2CM_RXDATA	DATA	0E2H
P31	BIT	0B0H.1
P22	BIT	0A0H.2
P13	BIT	090H.3
P04	BIT	080H.4
P32	BIT	0B0H.2
P23	BIT	0A0H.3
P14	BIT	090H.4
P05	BIT	080H.5
I2CM_TXDATA	DATA	0E3H
CCMCON	DATA	08EH
TMOD	DATA	089H
TCON	DATA	088H
P33	BIT	0B0H.3
P24	BIT	0A0H.4
P15	BIT	090H.5
P06	BIT	080H.6
P34	BIT	0B0H.4
P25	BIT	0A0H.5
P16	BIT	090H.6
P07	BIT	080H.7
INT_USB	BIT	0C0H.2
P35	BIT	0B0H.5
P26	BIT	0A0H.6
P17	BIT	090H.7
CCMVAL	DATA	08FH
P36	BIT	0B0H.6
P27	BIT	0A0H.7
INT_SPI	BIT	0C0H.0
I2CS_RXDATA	DATA	0F2H
I2CS_TXRX_IE	DATA	0D6H
SPCR	DATA	0B1H
P37	BIT	0B0H.7
SPDR	DATA	0B2H
I2CS_TXDATA	DATA	0F3H
INT_EXT	BIT	0C0H.4
IE0	BIT	088H.1
IE1	BIT	088H.3
PAGE_A	DATA	09BH
PAGE_B	DATA	09CH
B	DATA	0F0H
MD0	DATA	0C1H
PAGE_C	DATA	09DH
MD1	DATA	0C2H
MD2	DATA	0C3H
CP_RL2	BIT	0C8H.0
MD3	DATA	0C4H
MD4	DATA	0C5H
MD5	DATA	0C6H
ACC	DATA	0E0H
ES0	BIT	0A8H.4
PWM0_C	DATA	0A2H
ET0	BIT	0A8H.1
ES1	BIT	0A8H.6
PWM1_C	DATA	0DDH
SPSR	DATA	0B3H
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RB8	BIT	098H.2
TH0	DATA	08CH
key_r0	BIT	0B0H.3
INT_XVR	BIT	0C0H.3
EX0	BIT	0A8H.0
IT0	BIT	088H.0
TH1	DATA	08DH
key_r1	BIT	0B0H.2
key_s0	BIT	0A0H.7
TB8	BIT	098H.3
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
key_r2	BIT	0B0H.1
key_s1	BIT	0A0H.6
EX2	BIT	0E8H.0
P	BIT	0D0H.0
AIE	DATA	0E8H
key_r3	BIT	0B0H.0
key_s2	BIT	0A0H.4
EX3	BIT	0E8H.1
SM0	BIT	098H.7
AIF	DATA	0C0H
TL0	DATA	08AH
key_s3	BIT	0A0H.0
EX4	BIT	0E8H.2
SM1	BIT	098H.6
TL1	DATA	08BH
EX5	BIT	0E8H.3
SM2	BIT	098H.5
TL2	DATA	0CCH
EX6	BIT	0E8H.4
EX7	BIT	0E8H.5
EX8	BIT	0E8H.6
RS0	BIT	0D0H.3
EX9	BIT	0E8H.7
TR0	BIT	088H.4
RS1	BIT	0D0H.4
TR1	BIT	088H.6
I2CM_CALLADDR0	DATA	0D4H
TR2	BIT	0C8H.2
NMI_EN	DATA	0C9H
AIP	DATA	0F8H
DPH	DATA	083H
DPL	DATA	082H
SBUF0	DATA	099H
PALT0	DATA	0E9H
EXEN2	BIT	0C8H.3
PALT1	DATA	0F7H
I2CM_DATA_STS	DATA	0E6H
PCON2	DATA	086H
SCON0	DATA	098H
REN	BIT	098H.4
T2CON	DATA	0C8H
I2CS_DATA_STS	DATA	0F6H
I2CM_PRESC	DATA	0E4H
I2CS_SELFADDR0	DATA	0D7H
MPAGE	DATA	0A1H
P0OUT_EN	DATA	09AH
MMS	DATA	097H
P0_WUMOD	DATA	0F9H
P1OUT_EN	DATA	09EH
P1_WUMOD	DATA	0FAH
WDT	DATA	0A6H
PWM0_DCLSB	DATA	0A3H
P2OUT_EN	DATA	09FH
CKCON	DATA	084H
P2_WUMOD	DATA	0FBH
PWM1_DCLSB	DATA	0DEH
P3OUT_EN	DATA	0A5H
PWM0_DCMSB	DATA	0A4H
P3_WUMOD	DATA	0FCH
I2CS_PRESC	DATA	0F4H
PWM1_DCMSB	DATA	0DFH
P4OUT_EN	DATA	0A7H
P4_WUMOD	DATA	0FDH
ASBUF	DATA	0BDH
P0_PD	DATA	0AEH
F0	BIT	0D0H.5
MDCTL	DATA	0C7H
ASCON	DATA	0BCH
P1_PD	DATA	0AFH
I2CM_DATA_IE	DATA	0D2H
P2_PD	DATA	0B4H
P3_PD	DATA	0B5H
P4_PD	DATA	0B6H
DPSEL	DATA	092H
PSW	DATA	0D0H
I2CS_DATA_IE	DATA	0D5H
?PR?Ble_Packet_Encode?MAIN               SEGMENT CODE 
?PR?FuncLED_Init?MAIN                    SEGMENT CODE 
?PR?Open_FuncLED?MAIN                    SEGMENT CODE 
?PR?Close_FuncLED?MAIN                   SEGMENT CODE 
?PR?mcu_io_sleep?MAIN                    SEGMENT CODE 
?PR?gpio_init?MAIN   SEGMENT CODE 
?PR?mcu_clk_inital?MAIN                  SEGMENT CODE 
?PR?Sys_SleepModeCheck?MAIN              SEGMENT CODE 
?PR?Sys_PowerOn?MAIN SEGMENT CODE 
?PR?Sys_PowerDown?MAIN                   SEGMENT CODE 
?PR?KeyP2_scan_func?MAIN                 SEGMENT CODE 
?PR?_Key_scan_func?MAIN                  SEGMENT CODE 
?PR?Key24_Detect_GPIO?MAIN               SEGMENT CODE 
?XD?Key24_Detect_GPIO?MAIN               SEGMENT XDATA OVERLAYABLE 
?PR?Calc_CRC_Value?MAIN                  SEGMENT CODE 
?PR?Set_Common_com_Data?MAIN             SEGMENT CODE 
?PR?Set_Common_Tx_Data?MAIN              SEGMENT CODE 
?PR?ShortKey_PowerOn?MAIN                SEGMENT CODE 
?PR?ShortKey_PowerOff?MAIN               SEGMENT CODE 
?PR?ShortKey_E?MAIN  SEGMENT CODE 
?PR?ShortKey_S_sub?MAIN                  SEGMENT CODE 
?PR?ShortKey_S_add?MAIN                  SEGMENT CODE 
?PR?ShortKey_White?MAIN                  SEGMENT CODE 
?PR?ShortKey_Red?MAIN                    SEGMENT CODE 
?PR?ShortKey_B_add?MAIN                  SEGMENT CODE 
?PR?ShortKey_Yellow?MAIN                 SEGMENT CODE 
?PR?ShortKey_Green?MAIN                  SEGMENT CODE 
?PR?ShortKey_Scale?MAIN                  SEGMENT CODE 
?PR?ShortKey_Color?MAIN                  SEGMENT CODE 
?PR?ShortKey_Blue?MAIN                   SEGMENT CODE 
?PR?ShortKey_B_sub?MAIN                  SEGMENT CODE 
?PR?ShortKey_M1?MAIN SEGMENT CODE 
?PR?ShortKey_M2?MAIN SEGMENT CODE 
?PR?ShortKey_M3?MAIN SEGMENT CODE 
?PR?ShortKey_M4?MAIN SEGMENT CODE 
?PR?ShortKey_M5?MAIN SEGMENT CODE 
?PR?ShortKey_M6?MAIN SEGMENT CODE 
?PR?ShortKey_M7?MAIN SEGMENT CODE 
?PR?ShortKey_M8?MAIN SEGMENT CODE 
?PR?ShortKey_M9?MAIN SEGMENT CODE 
?PR?_LongKey_Indentify?MAIN              SEGMENT CODE 
?PR?LongKey_PowerOn?MAIN                 SEGMENT CODE 
?PR?LongKey_PowerOff?MAIN                SEGMENT CODE 
?PR?LongKey_E?MAIN   SEGMENT CODE 
?PR?LongKey_Color?MAIN                   SEGMENT CODE 
?PR?Key_Scan?MAIN    SEGMENT CODE 
?XD?Key_Scan?MAIN    SEGMENT XDATA OVERLAYABLE 
?PR?TX_CMD_USE_BLE_mode?MAIN             SEGMENT CODE 
?PR?Get_MacAddr?MAIN SEGMENT CODE 
?PR?Set_MacAddr?MAIN SEGMENT CODE 
?PR?Power_On_Init?MAIN                   SEGMENT CODE 
?XD?Power_On_Init?MAIN                   SEGMENT XDATA OVERLAYABLE 
?PR?main?MAIN        SEGMENT CODE 
?CO?MAIN             SEGMENT CODE 
?C_INITSEG           SEGMENT CODE 
?XD?MAIN             SEGMENT XDATA 
?BI?MAIN             SEGMENT BIT 
	EXTRN	CODE (Sys_set_1MHZ_rate)
	EXTRN	XDATA (cRemoteIDLETime)
	EXTRN	BIT (bPowerDN)
	EXTRN	XDATA (u2msFlag)
	EXTRN	XDATA (wIdleTime)
	EXTRN	CODE (_BlePacketDeductive)
	EXTRN	XDATA (?_BlePacketDeductive?BYTE)
	EXTRN	DATA (CLK_EN_CFG_TEMP)
	EXTRN	CODE (_Delay_ms)
	EXTRN	XDATA (u10msFlag)
	EXTRN	XDATA (u20msFlag)
	EXTRN	BIT (adv_flag)
	EXTRN	XDATA (g_patchPALT1)
	EXTRN	XDATA (RF_TxFlag)
	EXTRN	CODE (_BlePacketEncode)
	EXTRN	XDATA (?_BlePacketEncode?BYTE)
	EXTRN	CODE (PowerDown_Rf)
	EXTRN	XDATA (adv_flag_count)
	EXTRN	XDATA (uart_data_send)
	EXTRN	CODE (_driver_uart_send_start)
	EXTRN	CODE (InitSysTimer)
	EXTRN	CODE (_WaitUs)
	EXTRN	CODE (_logvalue)
	EXTRN	BIT (power_on)
	EXTRN	CODE (PowerUp_Rf)
	EXTRN	CODE (_loginfo)
	EXTRN	CODE (_RF_TXNoAck)
	EXTRN	CODE (Close_Uart)
	EXTRN	CODE (_UartConfig)
	EXTRN	CODE (?C?ICALL)
	EXTRN	CODE (?C?COPY)
	EXTRN	CODE (?C_STARTUP)
	PUBLIC	rf_encode_39
	PUBLIC	long_key_value_temp
	PUBLIC	rf_encode_38
	PUBLIC	rf_encode_37
	PUBLIC	rgb_static_dynamic
	PUBLIC	long_key_value_tempp
	PUBLIC	Static_scene_state
	PUBLIC	tx_data_seted
	PUBLIC	KeyCode1
	PUBLIC	Payload_demo
	PUBLIC	short_long_touch_flag
	PUBLIC	RF_TxBuf_CH39
	PUBLIC	RF_TxBuf_CH38
	PUBLIC	RF_TxBuf_CH37
	PUBLIC	SrcAddr_1
	PUBLIC	KeyCount
	PUBLIC	BLE_PacketLen
	PUBLIC	rf_encode_state
	PUBLIC	RF_TxLen_CH3789
	PUBLIC	BLE_PacketBuf
	PUBLIC	longCount_scale
	PUBLIC	KeyCode
	PUBLIC	fen_Duan
	PUBLIC	single_RF_test
	PUBLIC	SequenceNum_inc_1
	PUBLIC	AdvPacket_2
	PUBLIC	CurrentGroup_1
	PUBLIC	SequenceNum_1
	PUBLIC	Key24_TBL
	PUBLIC	Key_TBL
	PUBLIC	main
	PUBLIC	Power_On_Init
	PUBLIC	Set_MacAddr
	PUBLIC	Get_MacAddr
	PUBLIC	TX_CMD_USE_BLE_mode
	PUBLIC	Key_Scan
	PUBLIC	LongKey_Color
	PUBLIC	LongKey_E
	PUBLIC	LongKey_PowerOff
	PUBLIC	LongKey_PowerOn
	PUBLIC	_LongKey_Indentify
	PUBLIC	ShortKey_M9
	PUBLIC	ShortKey_M8
	PUBLIC	ShortKey_M7
	PUBLIC	ShortKey_M6
	PUBLIC	ShortKey_M5
	PUBLIC	ShortKey_M4
	PUBLIC	ShortKey_M3
	PUBLIC	ShortKey_M2
	PUBLIC	ShortKey_M1
	PUBLIC	ShortKey_B_sub
	PUBLIC	ShortKey_Blue
	PUBLIC	ShortKey_Color
	PUBLIC	ShortKey_Scale
	PUBLIC	ShortKey_Green
	PUBLIC	ShortKey_Yellow
	PUBLIC	ShortKey_B_add
	PUBLIC	ShortKey_Red
	PUBLIC	ShortKey_White
	PUBLIC	ShortKey_S_add
	PUBLIC	ShortKey_S_sub
	PUBLIC	ShortKey_E
	PUBLIC	ShortKey_PowerOff
	PUBLIC	ShortKey_PowerOn
	PUBLIC	Set_Common_Tx_Data
	PUBLIC	Set_Common_com_Data
	PUBLIC	Calc_CRC_Value
	PUBLIC	Key24_Detect_GPIO
	PUBLIC	_Key_scan_func
	PUBLIC	KeyP2_scan_func
	PUBLIC	Sys_PowerDown
	PUBLIC	Sys_PowerOn
	PUBLIC	Sys_SleepModeCheck
	PUBLIC	mcu_clk_inital
	PUBLIC	gpio_init
	PUBLIC	mcu_io_sleep
	PUBLIC	Close_FuncLED
	PUBLIC	Open_FuncLED
	PUBLIC	FuncLED_Init
	PUBLIC	Ble_Packet_Encode

	RSEG  ?XD?Key_Scan?MAIN
?Key_Scan?BYTE:
     inKey?4446:   DS   1

	RSEG  ?XD?Power_On_Init?MAIN
?Power_On_Init?BYTE:
         i?4847:   DS   1

	RSEG  ?XD?Key24_Detect_GPIO?MAIN
?Key24_Detect_GPIO?BYTE:
 key_value?1242:   DS   1

	RSEG  ?XD?MAIN
  SequenceNum_1:   DS   1
 CurrentGroup_1:   DS   1
    AdvPacket_2:   DS   32
SequenceNum_inc_1:   DS   1
 single_RF_test:   DS   1
       fen_Duan:   DS   1
        KeyCode:   DS   1
longCount_scale:   DS   1
  BLE_PacketBuf:   DS   32
RF_TxLen_CH3789:   DS   1
rf_encode_state:   DS   1
  BLE_PacketLen:   DS   1
       KeyCount:   DS   2
      SrcAddr_1:   DS   4
  RF_TxBuf_CH37:   DS   32
  RF_TxBuf_CH38:   DS   32
  RF_TxBuf_CH39:   DS   32
short_long_touch_flag:   DS   1
   Payload_demo:   DS   32
       KeyCode1:   DS   1
Static_scene_state:   DS   1
long_key_value_tempp:   DS   1
rgb_static_dynamic:   DS   1
long_key_value_temp:   DS   1

	RSEG  ?BI?MAIN
  tx_data_seted:   DBIT   1
   rf_encode_37:   DBIT   1
   rf_encode_38:   DBIT   1
   rf_encode_39:   DBIT   1

	RSEG  ?CO?MAIN
?SC_0:
	DB  'P' ,'w' ,'o' ,'n' ,00DH,00AH,000H

?SC_7:
	DB  'P' ,'w' ,'o' ,'f' ,'f' ,00DH,00AH,000H

?SC_15:
	DB  'K' ,'_' ,'E' ,00DH,00AH,000H

?SC_21:
	DB  'K' ,'_' ,'S' ,' ' ,'s' ,'u' ,'b' ,00DH,00AH,000H

?SC_31:
	DB  'K' ,'_' ,'S' ,' ' ,'a' ,'d' ,'d' ,00DH,00AH,000H

?SC_41:
	DB  'K' ,'_' ,'w' ,'h' ,'i' ,'t' ,'e' ,00DH,00AH,000H

?SC_51:
	DB  'K' ,'_' ,'r' ,'e' ,'d' ,00DH,00AH,000H

?SC_59:
	DB  'K' ,'_' ,'b' ,' ' ,'a' ,'d' ,'d' ,00DH,00AH,000H

?SC_69:
	DB  'K' ,'_' ,'y' ,'e' ,'l' ,'l' ,'o' ,'w' ,00DH,00AH
	DB  000H

?SC_80:
	DB  'K' ,'_' ,'g' ,'r' ,'e' ,'e' ,'n' ,00DH,00AH,000H

?SC_90:
	DB  'K' ,'_' ,'s' ,'c' ,'a' ,'l' ,'e' ,00DH,00AH,000H

?SC_100:
	DB  'K' ,'_' ,'c' ,'o' ,'l' ,'o' ,'r' ,00DH,00AH,000H

?SC_110:
	DB  'K' ,'_' ,'b' ,'l' ,'u' ,'e' ,00DH,00AH,000H

?SC_119:
	DB  'K' ,'_' ,'b' ,' ' ,'s' ,'u' ,'b' ,00DH,00AH,000H

?SC_129:
	DB  'K' ,' ' ,'m' ,'1' ,00DH,00AH,000H

?SC_136:
	DB  'K' ,' ' ,'m' ,'2' ,00DH,00AH,000H

?SC_143:
	DB  'K' ,' ' ,'m' ,'3' ,00DH,00AH,000H

?SC_150:
	DB  'K' ,' ' ,'m' ,'4' ,00DH,00AH,000H

?SC_157:
	DB  'K' ,' ' ,'m' ,'5' ,00DH,00AH,000H

?SC_164:
	DB  'K' ,' ' ,'m' ,'6' ,00DH,00AH,000H

?SC_171:
	DB  'K' ,' ' ,'m' ,'7' ,00DH,00AH,000H

?SC_178:
	DB  'K' ,' ' ,'m' ,'8' ,00DH,00AH,000H

?SC_185:
	DB  'K' ,' ' ,'m' ,'9' ,00DH,00AH,000H

?SC_192:
	DB  'L' ,'K' ,' ' ,'p' ,'w' ,'o' ,'n' ,00DH,00AH,000H

?SC_202:
	DB  'L' ,'K' ,' ' ,'p' ,'w' ,'o' ,'f' ,'f' ,00DH,00AH
	DB  000H

?SC_213:
	DB  'L' ,'K' ,' ' ,'e' ,00DH,00AH,000H

?SC_220:
	DB  'L' ,'K' ,' ' ,'c' ,'l' ,00DH,00AH,000H

?SC_228:
	DB  'K' ,'e' ,'r' ,'r' ,000H

Key_TBL:
	DB	000H
	DB	001H
	DB	00DH
	DB	009H
	DB	003H
	DB	002H
	DB	00CH
	DB	008H
	DB	004H
	DB	011H
	DB	00BH
	DB	007H
	DB	006H
	DB	011H
	DB	00EH
	DB	00AH
	DB	005H

Key24_TBL:
	DB	000H
	DB	000H,000H,000H	; ptr3
	DB	001H
	DB	0FFH
	DW	ShortKey_M3 + 0
	DB	002H
	DB	0FFH
	DW	ShortKey_Yellow + 0
	DB	003H
	DB	0FFH
	DW	ShortKey_M8 + 0
	DB	004H
	DB	0FFH
	DW	ShortKey_M1 + 0
	DB	005H
	DB	0FFH
	DW	ShortKey_B_sub + 0
	DB	006H
	DB	0FFH
	DW	ShortKey_S_add + 0
	DB	007H
	DB	0FFH
	DW	ShortKey_M6 + 0
	DB	008H
	DB	0FFH
	DW	ShortKey_PowerOn + 0
	DB	009H
	DB	0FFH
	DW	ShortKey_Scale + 0
	DB	00AH
	DB	0FFH
	DW	ShortKey_Red + 0
	DB	00BH
	DB	0FFH
	DW	ShortKey_M5 + 0
	DB	00CH
	DB	000H,000H,000H	; ptr3
	DB	00DH
	DB	0FFH
	DW	ShortKey_Green + 0
	DB	00EH
	DB	0FFH
	DW	ShortKey_White + 0
	DB	00FH
	DB	0FFH
	DW	ShortKey_M7 + 0
	DB	010H
	DB	0FFH
	DW	ShortKey_M9 + 0
	DB	011H
	DB	0FFH
	DW	ShortKey_Color + 0
	DB	012H
	DB	0FFH
	DW	ShortKey_S_sub + 0
	DB	013H
	DB	0FFH
	DW	ShortKey_M2 + 0
	DB	014H
	DB	0FFH
	DW	ShortKey_E + 0
	DB	015H
	DB	0FFH
	DW	ShortKey_Blue + 0
	DB	016H
	DB	0FFH
	DW	ShortKey_B_add + 0
	DB	017H
	DB	0FFH
	DW	ShortKey_M4 + 0
	DB	018H
	DB	0FFH
	DW	ShortKey_PowerOff + 0
	DB	019H
	DB	0FFH
	DW	LongKey_PowerOn + 0
	DB	01AH
	DB	0FFH
	DW	LongKey_PowerOff + 0
	DB	01BH
	DB	0FFH
	DW	LongKey_E + 0
	DB	01CH
	DB	0FFH
	DW	LongKey_Color + 0


	RSEG  ?C_INITSEG
	DB	0C1H, tx_data_seted + 000H	; bit-init

	DB	041H
	DW	KeyCode
	DB	000H

	DB	041H
	DW	KeyCode1
	DB	000H

	DB	042H
	DW	KeyCount
	DW	00000H

	DB	041H
	DW	longCount_scale
	DB	000H

	DB	041H
	DW	SequenceNum_1
	DB	000H

	DB	041H
	DW	long_key_value_temp
	DB	000H

	DB	041H
	DW	SequenceNum_inc_1
	DB	000H

	DB	041H
	DW	short_long_touch_flag
	DB	000H

	DB	041H
	DW	Static_scene_state
	DB	000H

	DB	060H
	DB	020H
	DW	AdvPacket_2
	DB	002H
	DB	01BH
	DB	0FEH
	DB	0EEH
	DB	0C0H
	DB	007H
	DB	0DAH
	DB	078H
	DB	013H
	DB	001H
	DB	004H
	DB	011H
	DB	007H
	DB	000H
	DB	010H
	DB	0FFH
	DB	001H
	DB	002H
	DB	003H
	DB	014H
	DB	000H
	DB	000H
	DB	000H
	DB	001H
	DB	000H
	DB	000H
	DB	0AAH
	DB  000H,000H,000H,000H,000H


	DB	041H
	DW	fen_Duan
	DB	000H

	DB	041H
	DW	rgb_static_dynamic
	DB	000H

	DB	041H
	DW	single_RF_test
	DB	000H

; #include "includes.h"
; 
; 
; unsigned char Payload_demo[Payload_len];
; bit	tx_data_seted=0;
; bit rf_encode_37,rf_encode_38,rf_encode_39;
; uint8 rf_encode_state;
; 
; uint8 KeyCode=0;
; uint8 KeyCode1=0;
; 
; uint16 KeyCount=0;
; uint8  longCount_scale = 0;
; uint8  SequenceNum_1=0;
; uint8 long_key_value_temp = 0;  //如果长按同一个键，则会保存当前值
; uint8 long_key_value_tempp;
; uint8  SequenceNum_inc_1 = 0;
; uint8 short_long_touch_flag = 0;
; 
; uint8 SrcAddr_1[4];
; uint8 CurrentGroup_1[1];
; uint8 Static_scene_state = 0;
; 
; #define PWM_OPEN_CLOCK() \
; 	{CLK_EN_CFG |= 0x10;}   //Enable pwm
; 
; #define PWM_SetupIOL(bl) \
;     PALT1_SETB(((bl)<<3))
; 
; #define	PWM1_SetupIOL(b1) \
; 	PALT1_SETB(((b1)<<4))
; 
; #define PWM_Setup(pn,pres,resol,duty) \
; 	PWM_##pn##_CFG = (((resol>=768)<<7)|(pres));\
; 	PWM_##pn##_RESOL = ((resol>=768)?(resol-768):(resol));\
; 	PWM_##pn##_DCLSB = (duty&0xff);\
; 	PWM_##pn##_DCMSB = ((duty>>8)&0xff)
; 
; #define PWM_SET_DUTY(pn,duty) \
; 	PWM_##pn##_DCLSB = (duty&0xff);\
; 	PWM_##pn##_DCMSB = ((duty>>8)&0xff)
; 
; #define PWM_Open(pn) \
; 	PWM_##pn##_CFG |= BIT(6)
; 
; #define PWM_CLOSE(pn) \
; 	PWM_##pn##_CFG &= _BIT(6)
; 
; 
; uint8   AdvPacket_2[32] = 
; {
; 	//0
;     0x02,   // 广播类型
;     
;     //27,   // 26 Length ( Device Address + Payload )
;     //1
;     27,
;     /* Device Address(6字节) */
;     //0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 
;     //2   3    4    5   6     7
;     0xfe,0xee,0xc0,0x07,0xda,0x78,                                 //6个字节
;     //0x0A,0xFF,0x5D,0x00,0x02,0x01,0x08,0xFF,0x00,0x00,0x00,
;     
;     // 0x0b,0xFF,0x5D,0x00,0x02,0x01,0x09,0x02,0x01,0x00,0x35,0xf3,   //12个字节
;     //8  9     10   11    12     13   14      15   16    17    18   19     20    21   22     23      24    25    26    27   28
;     //0  1     2    3     4       5    6       7    8     9    10    11    12    13   14     15      16    17    18	  19     20    //共21字节
;     
;     19,0x01,  0x04, 0x11,0x07,  0x00, 0x10,  0xff,0x01,  0x02, 0x03, 0x14, 0x00, 0x00,0x00 , 0x01,  0x00, 0x00, 0xAA//,   0xBB, 0xcc 
; };
; 
; #define KEY_PUSH_LONG		(0x80)
; #define KEY_PUSH_UP			(0x40)
; #define KEY_BOND_DOWN		(0x20)
; #define KEY_PUSH_DOWN		(0x00)
; 
; #define HAL_KEY_NO_KEY			0x00
; 
; #define HAL_KEY_POWER_ON		0x01
; #define HAL_KEY_POWER_OFF		0x02
; #define HAL_KEY_BRIGHT_UP		0x03
; #define HAL_KEY_BRIGHT_DOWN		0x04
; #define HAL_KEY_TEMP_UP			0x05
; #define HAL_KEY_TEMP_DOWN		0x06
; 
; #define HAL_KEY_POWER_ON1		0x07
; #define HAL_KEY_POWER_ON2		0x08
; #define HAL_KEY_POWER_ON3		0x09
; #define HAL_KEY_POWER_ON4		0x0a
; #define HAL_KEY_POWER_OFF1		0x0b
; #define HAL_KEY_POWER_OFF2		0x0c
; #define HAL_KEY_POWER_OFF3		0x0d
; #define HAL_KEY_POWER_OFF4		0x0e
; #define HAL_KEY_FACTORY_RESET   0x0f
; #define HAL_KEY_BIND            0x10
; 
; #define HAL_TXREAD_EEPROM		0x11
; #define HAL_RXREAD_EEPROM		(KEY_PUSH_UP|HAL_TXREAD_EEPROM)
; 
; // for key process 
; #define POWER_ON1_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_ON1)
; #define POWER_OFF1_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_OFF1)
; #define POWER_ON2_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_ON2)
; #define POWER_OFF2_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_OFF2)
; #define POWER_ON3_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_ON3)
; #define POWER_OFF3_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_OFF3)
; #define POWER_ON4_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_ON4)
; #define POWER_OFF4_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_OFF4)
; #define FACTORY_RESET_KEY      	(KEY_PUSH_UP|HAL_KEY_FACTORY_RESET)
; //#define BIND_KEY            	(KEY_PUSH_UP|HAL_KEY_BIND)
; 
; #define POWER_ON_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_ON)
; #define POWER_OFF_KEY			(KEY_PUSH_UP|HAL_KEY_POWER_OFF)
; #define BRIGHT_UP_KEY			(KEY_PUSH_UP|HAL_KEY_BRIGHT_UP)
; #define BRIGHT_DOWN_KEY		    (KEY_PUSH_UP|HAL_KEY_BRIGHT_DOWN)
; #define TEMP_UP_KEY				(KEY_PUSH_UP|HAL_KEY_TEMP_UP)
; #define TEMP_DOWN_KEY			(KEY_PUSH_UP|HAL_KEY_TEMP_DOWN)
; 
; #define DELAY_POWER_OFF_KEY		(KEY_PUSH_LONG|HAL_KEY_POWER_OFF)
; #define BRIGHT_MOVE_UP_KEY		(KEY_PUSH_LONG|HAL_KEY_BRIGHT_UP)
; #define BRIGHT_MOVE_DOWN_KEY	(KEY_PUSH_LONG|HAL_KEY_BRIGHT_DOWN)
; #define TEMP_MOVE_UP_KEY		(KEY_PUSH_LONG|HAL_KEY_TEMP_UP)
; #define TEMP_MOVE_DOWN_KEY		(KEY_PUSH_LONG|HAL_KEY_TEMP_DOWN)
; 
; 
; 
; code uint8 Key_TBL[17]={ 
; 	HAL_KEY_NO_KEY,		// 0x0 
; 	HAL_KEY_POWER_ON,	HAL_KEY_POWER_OFF3,	HAL_KEY_POWER_ON3,	HAL_KEY_BRIGHT_UP,		// 
; 	HAL_KEY_POWER_OFF,	HAL_KEY_POWER_OFF2,	HAL_KEY_POWER_ON2,	HAL_KEY_BRIGHT_DOWN,		// 
; 	HAL_TXREAD_EEPROM,	HAL_KEY_POWER_OFF1,	HAL_KEY_POWER_ON1,	HAL_KEY_TEMP_DOWN, 	// 
; 	HAL_TXREAD_EEPROM,	HAL_KEY_POWER_OFF4,	HAL_KEY_POWER_ON4,	HAL_KEY_TEMP_UP, 	//
; };
; 
; uint8  XDATA   RF_TxLen_CH3789;  //三个通道要发同一组数据，则其长度也要是一样
; volatile uint8  XDATA   RF_TxBuf_CH37[RF_TxBuf_CH3789_len];
; volatile uint8  XDATA   RF_TxBuf_CH38[RF_TxBuf_CH3789_len];
; volatile uint8  XDATA   RF_TxBuf_CH39[RF_TxBuf_CH3789_len];
; 
; uint8  XDATA   BLE_PacketBuf[BLE_PacketBuf_len];
; uint8  XDATA   BLE_PacketLen;
; uint8  fen_Duan=0,rgb_static_dynamic=0;
; void Set_MacAddr(void);
; 
; void Ble_Packet_Encode(void){

	RSEG  ?PR?Ble_Packet_Encode?MAIN
Ble_Packet_Encode:
	USING	0
			; SOURCE LINE # 144
; 	if(tx_data_seted){
			; SOURCE LINE # 145
	JB   	tx_data_seted,$ + 6H
	LJMP 	?C0006
; 		switch(rf_encode_state){
			; SOURCE LINE # 146
	MOV  	DPTR,#rf_encode_state
	MOVX 	A,@DPTR
	DEC  	A
	JZ   	?C0004
	DEC  	A
	JZ   	?C0005
	ADD  	A,#02H
	JNZ  	?C0006
; 			case 0:
			; SOURCE LINE # 147
?C0003:
; 				BlePacketEncode( RF_TxBuf_CH37, AdvPacket_2, 29, 37 );  //虽然这里长度写的是29，不过最终还会产生三个CRC校验码，因此fifo_data会多三bytes
			; SOURCE LINE # 148
	MOV  	DPTR,#?_BlePacketEncode?BYTE+03H
	MOV  	A,#01H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#HIGH (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#LOW (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#01DH
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#025H
	MOVX 	@DPTR,A
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH37)
	MOV  	R1,#LOW (RF_TxBuf_CH37)
	LCALL	_BlePacketEncode
; 				rf_encode_state = 1;
			; SOURCE LINE # 149
	MOV  	DPTR,#rf_encode_state
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 				rf_encode_37  = 1;
			; SOURCE LINE # 150
	SETB 	rf_encode_37
; 				break;
			; SOURCE LINE # 151
	RET  	
; 			case 1:
			; SOURCE LINE # 152
?C0004:
; 				BlePacketEncode( RF_TxBuf_CH38, AdvPacket_2, 29, 38 );
			; SOURCE LINE # 153
	MOV  	DPTR,#?_BlePacketEncode?BYTE+03H
	MOV  	A,#01H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#HIGH (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#LOW (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#01DH
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#026H
	MOVX 	@DPTR,A
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH38)
	MOV  	R1,#LOW (RF_TxBuf_CH38)
	LCALL	_BlePacketEncode
; 				rf_encode_state = 2;
			; SOURCE LINE # 154
	MOV  	DPTR,#rf_encode_state
	MOV  	A,#02H
	MOVX 	@DPTR,A
; 				rf_encode_38 = 1;
			; SOURCE LINE # 155
	SETB 	rf_encode_38
; 				break;
			; SOURCE LINE # 156
	RET  	
; 			case 2:
			; SOURCE LINE # 157
?C0005:
; 				BlePacketEncode( RF_TxBuf_CH39, AdvPacket_2, 29, 39 );
			; SOURCE LINE # 158
	MOV  	DPTR,#?_BlePacketEncode?BYTE+03H
	MOV  	A,#01H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#HIGH (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#LOW (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#01DH
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#027H
	MOVX 	@DPTR,A
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH39)
	MOV  	R1,#LOW (RF_TxBuf_CH39)
	LCALL	_BlePacketEncode
; 				rf_encode_state = 0;
			; SOURCE LINE # 159
	CLR  	A
	MOV  	DPTR,#rf_encode_state
	MOVX 	@DPTR,A
; 				rf_encode_39 = 1;
			; SOURCE LINE # 160
	SETB 	rf_encode_39
; 				tx_data_seted = 0;
			; SOURCE LINE # 161
	CLR  	tx_data_seted
; 				break;
			; SOURCE LINE # 162
; 			}
			; SOURCE LINE # 163
; 	}
			; SOURCE LINE # 164
; }
			; SOURCE LINE # 165
?C0006:
	RET  	
; END OF Ble_Packet_Encode

; 
; void FuncLED_Init(void)

	RSEG  ?PR?FuncLED_Init?MAIN
FuncLED_Init:
			; SOURCE LINE # 167
; {
			; SOURCE LINE # 168
; #if __FQ__
; 	PWM_OPEN_CLOCK();  //打开pwm功能
; #if FangZhen_Mode
; 	PWM1_SetupIOL(BIT(0));
; #else
; 	PWM_SetupIOL(BIT(0));
; #endif
; #endif
; }
			; SOURCE LINE # 177
	RET  	
; END OF FuncLED_Init

; 
; void Open_FuncLED(void)

	RSEG  ?PR?Open_FuncLED?MAIN
Open_FuncLED:
			; SOURCE LINE # 179
; {
			; SOURCE LINE # 180
; #if __FQ__
; 
; #if FangZhen_Mode   //在仿真模式下，不能使用VPP输出pwm信号
; 	PWM_Setup(1, 39, (768+232), (768));
; 	PWM_Open(1);
; #else
; 	PWM_Setup(0, 39, (768+232), (768));
; 	PWM_Open(0);
; #endif
; 
; #endif
; }
			; SOURCE LINE # 192
	RET  	
; END OF Open_FuncLED

; 
; void Close_FuncLED(void)

	RSEG  ?PR?Close_FuncLED?MAIN
Close_FuncLED:
			; SOURCE LINE # 194
; {
			; SOURCE LINE # 195
; #if __FQ__
; 
; #if FangZhen_Mode  //在仿真模式下，不能使用VPP输出pwm信号
; 	PWM_CLOSE(1);
; #else
; 	PWM_CLOSE(0);
; #endif
; 
; #endif
; }
			; SOURCE LINE # 205
	RET  	
; END OF Close_FuncLED

; 
; void mcu_io_sleep()

	RSEG  ?PR?mcu_io_sleep?MAIN
mcu_io_sleep:
	USING	0
			; SOURCE LINE # 207
; {
			; SOURCE LINE # 208
; #if Package_SOP16
;     GPIO_InputSetup(1, 0xff, 0xff,0);
			; SOURCE LINE # 210
	MOV  	P1IN_EN,#0FFH
	MOV  	P1OUT_EN,#0FFH
	MOV  	P1_PU,#0FFH
;  	GPIO_OutputSetup(2, BIT(0)|BIT(1)|BIT(6)|BIT(7), 0);
			; SOURCE LINE # 211
	ANL  	P2IN_EN,#03CH
	ANL  	P2OUT_EN,#03CH
; 	GPIO_InputSetup(2,(~(BIT(0)|BIT(1)|BIT(6)|BIT(7))), (~(BIT(0)|BIT(1)|BIT(6)|BIT(7))),0);
			; SOURCE LINE # 212
	ORL  	P2IN_EN,#03CH
	ORL  	P2OUT_EN,#03CH
	ORL  	P2_PU,#03CH
; 	GPIO_DiablePU(2,BIT(0)|BIT(1)|BIT(6)|BIT(7));
			; SOURCE LINE # 213
	ANL  	P2_PU,#03CH
; 	GPIO_DiablePD(2,0xff);
			; SOURCE LINE # 214
	MOV  	P2_PD,#00H
; 	key_s0 = 0;
			; SOURCE LINE # 215
	CLR  	key_s0
; 	key_s1 = 0;	
			; SOURCE LINE # 216
	CLR  	key_s1
; 	key_s2 = 0;
			; SOURCE LINE # 217
	CLR  	key_s2
; 	key_s3 = 0;
			; SOURCE LINE # 218
	CLR  	key_s3
; 	GPIO_InputSetup(3, 0xff, 0xff,0);
			; SOURCE LINE # 219
	MOV  	P3IN_EN,#0FFH
	MOV  	P3OUT_EN,#0FFH
	MOV  	P3_PU,#0FFH
; #else
; 	GPIO_InputSetup(1, 0xff, 0xff,0);
; 	GPIO_OutputSetup(2, BIT(2)|BIT(3)|BIT(6)|BIT(7), 0);
; 	GPIO_InputSetup(2,(~(BIT(2)|BIT(3)|BIT(6)|BIT(7))), (~(BIT(2)|BIT(3)|BIT(6)|BIT(7))),0);
; 	GPIO_DiablePU(2,BIT(2)|BIT(3)|BIT(6)|BIT(7));
; 	GPIO_DiablePD(2,0xff);
; 	key_s0 = 0;
; 	key_s1 = 0; 
; 	key_s2 = 0;
; 	key_s3 = 0;
; 	GPIO_InputSetup(3, 0xff, 0xff,0);
; #endif
; 	Delay_ms(1);
			; SOURCE LINE # 232
	MOV  	R7,#01H
	MOV  	R6,#00H
	LJMP 	_Delay_ms
; END OF mcu_io_sleep

; }
; 
; void gpio_init()

	RSEG  ?PR?gpio_init?MAIN
gpio_init:
			; SOURCE LINE # 235
; {
			; SOURCE LINE # 236
; #if Package_SOP16
; 	GPIO_OutputSetup(2, BIT(0)|BIT(1)|BIT(6)|BIT(7), 0);
			; SOURCE LINE # 238
	ANL  	P2IN_EN,#03CH
	ANL  	P2OUT_EN,#03CH
;     GPIO_InputSetup(3, BIT(4)|BIT(5)|BIT(6)|BIT(7), BIT(4)|BIT(5)|BIT(6)|BIT(7),0);
			; SOURCE LINE # 239
	ORL  	P3IN_EN,#0F0H
	ORL  	P3OUT_EN,#0F0H
	ORL  	P3_PU,#0F0H
; #endif
; #if Package_QFN24
; 	GPIO_OutputSetup(2, BIT(2)|BIT(3)|BIT(6)|BIT(7), 0);
; 	GPIO_InputSetup(3, BIT(3)|BIT(2)|BIT(1)|BIT(0), BIT(3)|BIT(2)|BIT(1)|BIT(0),0);
; 	GPIO_OutputSetup(1,BIT(1),0);
; 	GPIO_DiablePU(1, BIT(1));
; 	LED_Test = 0;
; #endif
; 
;     key_s0 = 0;
			; SOURCE LINE # 249
	CLR  	key_s0
; 	key_s1 = 0;
			; SOURCE LINE # 250
	CLR  	key_s1
; 	key_s2 = 0;
			; SOURCE LINE # 251
	CLR  	key_s2
; 	key_s3 = 0;
			; SOURCE LINE # 252
	CLR  	key_s3
; }
			; SOURCE LINE # 253
	RET  	
; END OF gpio_init

; 
; void mcu_clk_inital(void)

	RSEG  ?PR?mcu_clk_inital?MAIN
mcu_clk_inital:
			; SOURCE LINE # 255
; {
			; SOURCE LINE # 256
; 	PCON=0;          // 2018/12/11
			; SOURCE LINE # 257
	CLR  	A
	MOV  	PCON,A
; 	PCON2 = 0 ;	
			; SOURCE LINE # 258
	MOV  	PCON2,A
;     CLK_EN_CFG = 0x00 ;
			; SOURCE LINE # 259
	MOV  	CLK_EN_CFG,A
;     CKCON = 0x00;    // 2018/12/11
			; SOURCE LINE # 260
	MOV  	CKCON,A
; }
			; SOURCE LINE # 261
	RET  	
; END OF mcu_clk_inital

; 
; void Sys_SleepModeCheck(void)

	RSEG  ?PR?Sys_SleepModeCheck?MAIN
Sys_SleepModeCheck:
	USING	0
			; SOURCE LINE # 263
; {
			; SOURCE LINE # 264
; 	if(adv_flag)
			; SOURCE LINE # 265
	JB   	adv_flag,?C0026
; 		return;
;     wIdleTime++;
			; SOURCE LINE # 267
	MOV  	DPTR,#wIdleTime+01H
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
	JNZ  	?C0132
	MOV  	DPTR,#wIdleTime
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
?C0132:
;     if(wIdleTime > cRemoteIDLETime)
			; SOURCE LINE # 268
	MOV  	DPTR,#cRemoteIDLETime
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R7,A
	SETB 	C
	MOV  	DPTR,#wIdleTime+01H
	MOVX 	A,@DPTR
	SUBB 	A,R7
	MOV  	DPTR,#wIdleTime
	MOVX 	A,@DPTR
	SUBB 	A,R6
	JC   	?C0026
;     {
			; SOURCE LINE # 269
;         bPowerDN = 1;
			; SOURCE LINE # 270
	SETB 	bPowerDN
;         wIdleTime = 0;
			; SOURCE LINE # 271
	CLR  	A
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
;     }    
			; SOURCE LINE # 272
; }
			; SOURCE LINE # 273
?C0026:
	RET  	
; END OF Sys_SleepModeCheck

; 
; void Sys_PowerOn(void)

	RSEG  ?PR?Sys_PowerOn?MAIN
Sys_PowerOn:
	USING	0
			; SOURCE LINE # 275
; {
			; SOURCE LINE # 276
; 	if(power_on)	 				//MCU 从sleep 或 power_down唤醒
			; SOURCE LINE # 277
	JNB  	power_on,?C0029
; 	{
			; SOURCE LINE # 278
;         power_on = 0;
			; SOURCE LINE # 279
	CLR  	power_on
;         gpio_init();
			; SOURCE LINE # 280
	LCALL	gpio_init
; 		WaitUs(80);	
			; SOURCE LINE # 281
	MOV  	R7,#050H
	MOV  	R6,#00H
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
; 		PowerUp_Rf();
			; SOURCE LINE # 282
	LCALL	PowerUp_Rf
;         FLUSH_TX;
			; SOURCE LINE # 283
	MOV  	DPTR,#08B6H
	MOV  	A,#0A0H
	MOVX 	@DPTR,A
;         FLUSH_RX;	
			; SOURCE LINE # 284
	MOV  	A,#080H
	MOVX 	@DPTR,A
;         
;         #if UART_ENABLE
;     	UartConfig(BAUD);
			; SOURCE LINE # 287
	MOV  	R7,A
	MOV  	R6,#025H
	LCALL	_UartConfig
;     	WaitUs(60000);	
			; SOURCE LINE # 288
	MOV  	R7,#060H
	MOV  	R6,#0EAH
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
;         #endif
;         
; 		WaitUs(200);						//  120us for PLL locking after power up RF part.		
			; SOURCE LINE # 291
	MOV  	R7,#0C8H
	MOV  	R6,#00H
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
; 		InitSysTimer(); 
			; SOURCE LINE # 292
	LCALL	InitSysTimer
;         
; 		WaitUs(200);	
			; SOURCE LINE # 294
	MOV  	R7,#0C8H
	MOV  	R6,#00H
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
;         FuncLED_Init();
			; SOURCE LINE # 295
	LCALL	FuncLED_Init
; 		wIdleTime = 0;  
			; SOURCE LINE # 296
	CLR  	A
	MOV  	DPTR,#wIdleTime
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 297
; } 
			; SOURCE LINE # 298
?C0029:
	RET  	
; END OF Sys_PowerOn

; 
; void Sys_PowerDown(void)

	RSEG  ?PR?Sys_PowerDown?MAIN
Sys_PowerDown:
	USING	0
			; SOURCE LINE # 300
; {
			; SOURCE LINE # 301
;     if(bPowerDN)
			; SOURCE LINE # 302
	JNB  	bPowerDN,?C0031
;     { 
			; SOURCE LINE # 303
;         bPowerDN = 0;
			; SOURCE LINE # 304
	CLR  	bPowerDN
; 
;         Close_Uart();
			; SOURCE LINE # 306
	LCALL	Close_Uart
;         Close_FuncLED();
			; SOURCE LINE # 307
	LCALL	Close_FuncLED
;         
; 		EX5  = 0 ;
			; SOURCE LINE # 309
	CLR  	EX5
; 		PowerDown_Rf();	
			; SOURCE LINE # 310
	LCALL	PowerDown_Rf
; 		
; 		SysTimerStop();	
			; SOURCE LINE # 312
	CLR  	TR0
	CLR  	ET0
	CLR  	TR1
	CLR  	ET1
	MOV  	CLK_EN_CFG_TEMP,CLK_EN_CFG
	CLR  	A
	MOV  	CLK_EN_CFG,A
;         mcu_io_sleep();
			; SOURCE LINE # 313
	LCALL	mcu_io_sleep
;         
;         TRX_ANAPWD_CTRL0 |=0x11;
			; SOURCE LINE # 315
	MOV  	DPTR,#08E3H
	MOVX 	A,@DPTR
	ORL  	A,#011H
	MOVX 	@DPTR,A
; 
; #if FangZhen_Mode
;         P3_WUEN = 0x0F; 		// P3.0 P3.1 P3.2 P3.3 wakeup enable 
			; SOURCE LINE # 318
	MOV  	P3_WUEN,#0FH
;         P3_WUMOD = 0x00;	
			; SOURCE LINE # 319
	CLR  	A
	MOV  	P3_WUMOD,A
; #else
;         P3_WUEN = 0xF0; 		// P3.4 P3.5 P3.6 P3.7 wakeup enable 
;         P3_WUMOD = 0x00;
; #endif
; 
;      	TRX_ANAPWD_CTRL0 = 0x53;
			; SOURCE LINE # 325
	MOV  	A,#053H
	MOVX 	@DPTR,A
;      	
; 		WaitUs(200);
			; SOURCE LINE # 327
	MOV  	R7,#0C8H
	MOV  	R6,#00H
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
; 		MCU_SLEEP();
			; SOURCE LINE # 328
	MOV  	PCON2,#03H
;         _nop_();
			; SOURCE LINE # 329
	NOP  	
; 		_nop_();
			; SOURCE LINE # 330
	NOP  	
; 		_nop_();
			; SOURCE LINE # 331
	NOP  	
; 		_nop_();
			; SOURCE LINE # 332
	NOP  	
; 		_nop_();
			; SOURCE LINE # 333
	NOP  	
; 		_nop_();
			; SOURCE LINE # 334
	NOP  	
; 		_nop_();
			; SOURCE LINE # 335
	NOP  	
; 		_nop_();
			; SOURCE LINE # 336
	NOP  	
; 		_nop_();
			; SOURCE LINE # 337
	NOP  	
; 		_nop_();
			; SOURCE LINE # 338
	NOP  	
; 		_nop_();
			; SOURCE LINE # 339
	NOP  	
; 		_nop_();
			; SOURCE LINE # 340
	NOP  	
; 	    PCON2 = 0x00;
			; SOURCE LINE # 341
	CLR  	A
	MOV  	PCON2,A
; 		_nop_();
			; SOURCE LINE # 342
	NOP  	
; 		_nop_();
			; SOURCE LINE # 343
	NOP  	
; 		_nop_();
			; SOURCE LINE # 344
	NOP  	
; 		_nop_();
			; SOURCE LINE # 345
	NOP  	
; 		_nop_();
			; SOURCE LINE # 346
	NOP  	
; 		_nop_();
			; SOURCE LINE # 347
	NOP  	
; 		_nop_();
			; SOURCE LINE # 348
	NOP  	
; 		_nop_();
			; SOURCE LINE # 349
	NOP  	
; 		_nop_();
			; SOURCE LINE # 350
	NOP  	
; 		_nop_();
			; SOURCE LINE # 351
	NOP  	
; 		_nop_();
			; SOURCE LINE # 352
	NOP  	
; 		_nop_();
			; SOURCE LINE # 353
	NOP  	
; 		WaitUs(200);
			; SOURCE LINE # 354
	MOV  	R7,#0C8H
	MOV  	R6,A
	MOV  	R5,A
	MOV  	R4,A
	LCALL	_WaitUs
; 		power_on = 1;
			; SOURCE LINE # 355
	SETB 	power_on
; 			
;     }
			; SOURCE LINE # 357
; }
			; SOURCE LINE # 358
?C0031:
	RET  	
; END OF Sys_PowerDown

; 
; #if FangZhen_Mode
; #define KSA             0xd1    //P2.7  P2.6  P2.4 P2.0  is 1(high voltag)
; #define KS0             0x51    //P2.7 = 0
; #define KS1             0x91    //P2.6 = 0
; #define KS2             0xc1    //P2.4 = 0
; #define KS3             0xd0    //P2.0 = 0
; #define KEYSCANBIT(x)   P2=(x)
; #define NOKEYPUSH       0x0F    ////P3_1/2/3/4
; #define KEYREADBIT     (P3&NOKEYPUSH)
; #define KEYP2READ       P2
; 
; #else
; #define KSA             0xc3    //P2.7  P2.6  P2.1 P2.0  is 1(high voltag)
; #define KS0             0x43    //P2.7 = 0
; #define KS1       ss      0x83    //P2.6 = 0
; #define KS2             0xc1    //P2.1 = 0
; #define KS3             0xc2    //P2.0 = 0
; #define KEYSCANBIT(x)   P2=(x)
; #define NOKEYPUSH       0xF0        //P3_4/5/6/7
; #define KEYREADBIT     (P3&NOKEYPUSH)
; #define KEYP2READ       P2
; #endif
; 
; uint8 KeyP2_scan_func(){    

	RSEG  ?PR?KeyP2_scan_func?MAIN
KeyP2_scan_func:
	USING	0
			; SOURCE LINE # 383
;     int8 key_value = 0;
			; SOURCE LINE # 384
;---- Variable 'key_value?1040' assigned to Register 'R7' ----
	CLR  	A
	MOV  	R7,A
; #if FangZhen_Mode   //set P2.7  P2.6  P2.4 P2.0 input
;     GPIO_InputSetup(2, BIT(0)|BIT(4)|BIT(6)|BIT(7),BIT(0)|BIT(4)|BIT(6)|BIT(7), 0);
			; SOURCE LINE # 386
	ORL  	P2IN_EN,#0D1H
	ORL  	P2OUT_EN,#0D1H
	ORL  	P2_PU,#0D1H
;     GPIO_OutputSetup(3, BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7), 0);//P3.7  P3.6  P3.4 P3.5
			; SOURCE LINE # 387
	MOV  	P3IN_EN,A
	MOV  	P3OUT_EN,A
?C0035:
; #else
;     //set P2.7  P2.6  P2.1 P2.0 input
; 	GPIO_InputSetup(2, BIT(0)|BIT(1)|BIT(6)|BIT(7),BIT(0)|BIT(1)|BIT(6)|BIT(7), 0);
; #endif
; 
;     while((KEYP2READ&KSA) != KSA){        
			; SOURCE LINE # 393
	MOV  	A,P2
	ANL  	A,#0D1H
	XRL  	A,#0D1H
	JZ   	?C0036
;         //logvalue(P2,P2, 0xb2);
;         if(key_s0 == 0){key_value = 1; break;}
			; SOURCE LINE # 395
	JB   	key_s0,?C0037
	MOV  	R7,#01H
	SJMP 	?C0036
?C0037:
;         if(key_s1 == 0){key_value = 2; break;}
			; SOURCE LINE # 396
	JB   	key_s1,?C0038
	MOV  	R7,#02H
	SJMP 	?C0036
?C0038:
;         if(key_s2 == 0){key_value = 3; break;}
			; SOURCE LINE # 397
	JB   	key_s2,?C0039
	MOV  	R7,#03H
	SJMP 	?C0036
?C0039:
;         if(key_s3 == 0){key_value = 4; break;}
			; SOURCE LINE # 398
	JB   	key_s3,?C0035
	MOV  	R7,#04H
;      }
			; SOURCE LINE # 399
?C0036:
; 
; #if FangZhen_Mode
;     GPIO_OutputSetup(2, BIT(0)|BIT(4)|BIT(6)|BIT(7), 0);
			; SOURCE LINE # 402
	ANL  	P2IN_EN,#02EH
	ANL  	P2OUT_EN,#02EH
; #else
;     //set P2.7  P2.6  P2.1 P2.0 output
; 	GPIO_OutputSetup(2, BIT(0)|BIT(1)|BIT(6)|BIT(7), 0);
; #endif    
;     return key_value;
			; SOURCE LINE # 407
; }
			; SOURCE LINE # 408
	RET  	
; END OF KeyP2_scan_func

; 
; uint8 Key_scan_func(uint8 keyscan){  

	RSEG  ?PR?_Key_scan_func?MAIN
_Key_scan_func:
	USING	0
			; SOURCE LINE # 410
;---- Variable 'keyscan?1141' assigned to Register 'R7' ----
; #if FangZhen_Mode
;     GPIO_OutputSetup(2, BIT(0)|BIT(4)|BIT(6)|BIT(7), 0);//P2.7  P2.6  P2.4P2.0
			; SOURCE LINE # 412
	ANL  	P2IN_EN,#02EH
	ANL  	P2OUT_EN,#02EH
;     GPIO_InputSetup(3, BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7),
;                           BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7), 0);//P3.7  P3.6  P3.4 P3.5
			; SOURCE LINE # 414
	MOV  	P3IN_EN,#0FFH
	MOV  	P3OUT_EN,#0FFH
	MOV  	P3_PU,#0FFH
; #else
; 	GPIO_OutputSetup(2, BIT(0)|BIT(1)|BIT(6)|BIT(7), 0);//P2.7  P2.6  P2.1 P2.0
; 	GPIO_InputSetup(3, BIT(4)|BIT(5)|BIT(6)|BIT(7),BIT(4)|BIT(5)|BIT(6)|BIT(7), 0);//P3.7  P3.6  P3.4 P3.5
; 	GPIO_InputSetup(3, BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7),
;                           BIT(0)|BIT(1)|BIT(2)|BIT(3)|BIT(4)|BIT(5)|BIT(6)|BIT(7), 0);//P3.7  P3.6  P3.4 P3.5
; #endif
;    // if(!key_r0)       {loginfo("37Low\r\n");}   else       {loginfo("37High\r\n");}    return 0;  // for test
;    
;     KEYSCANBIT(keyscan); 
			; SOURCE LINE # 423
	MOV  	P2,R7
;     //logvalue(P3,P3, 0xb3); 
;     if(KEYREADBIT != NOKEYPUSH){
			; SOURCE LINE # 425
	MOV  	A,P3
	ANL  	A,#0FH
	XRL  	A,#0FH
	JZ   	?C0046
;         if(!key_r3) return 5;
			; SOURCE LINE # 426
	JB   	key_r3,?C0047
	MOV  	R7,#05H
	RET  	
?C0047:
;         if(!key_r2) return 6;
			; SOURCE LINE # 427
	JB   	key_r2,?C0049
	MOV  	R7,#06H
	RET  	
?C0049:
;         if(!key_r1) return 7;
			; SOURCE LINE # 428
	JB   	key_r1,?C0050
	MOV  	R7,#07H
	RET  	
?C0050:
;         if(!key_r0) return 8;        
			; SOURCE LINE # 429
	JB   	key_r0,?C0046
	MOV  	R7,#08H
	RET  	
;     }
			; SOURCE LINE # 430
?C0046:
;     return 0;
			; SOURCE LINE # 431
	MOV  	R7,#00H
; }
			; SOURCE LINE # 432
?C0048:
	RET  	
; END OF _Key_scan_func

; 
; //key value: 1 2 3 4 5 6 ... 24
; //8 6 5 7   11 10 9  16 15 13
; uint8 Key24_Detect_GPIO(void){

	RSEG  ?PR?Key24_Detect_GPIO?MAIN
Key24_Detect_GPIO:
	USING	0
			; SOURCE LINE # 436
;     int8 key_value = 0;
			; SOURCE LINE # 437
	CLR  	A
	MOV  	DPTR,#key_value?1242
	MOVX 	@DPTR,A
;     if(key_value = KeyP2_scan_func()) { logvalue(0xEA,key_value, 1);      return (key_value);}
			; SOURCE LINE # 438
	LCALL	KeyP2_scan_func
	MOV  	A,R7
	MOVX 	@DPTR,A
	JZ   	?C0052
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	R3,#01H
	MOV  	R7,#0EAH
	SJMP 	?C0133
?C0052:
;     if(key_value = Key_scan_func(KSA)){ logvalue(0xEF,(key_value+16), 1); return (key_value+16);} 
			; SOURCE LINE # 439
	MOV  	R7,#0D1H
	LCALL	_Key_scan_func
	MOV  	DPTR,#key_value?1242
	MOV  	A,R7
	MOVX 	@DPTR,A
	JZ   	?C0054
	MOVX 	A,@DPTR
	ADD  	A,#010H
	MOV  	R5,A
	MOV  	R3,#01H
	MOV  	R7,#0EFH
	LCALL	_logvalue
	MOV  	DPTR,#key_value?1242
	MOVX 	A,@DPTR
	ADD  	A,#010H
	MOV  	R7,A
	RET  	
?C0054:
;     
;     if(key_value = Key_scan_func(KS0)){ logvalue(0xEB,key_value, 1);       return (key_value);}
			; SOURCE LINE # 441
	MOV  	R7,#051H
	LCALL	_Key_scan_func
	MOV  	DPTR,#key_value?1242
	MOV  	A,R7
	MOVX 	@DPTR,A
	JZ   	?C0055
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	R3,#01H
	MOV  	R7,#0EBH
?C0133:
	LCALL	_logvalue
	SJMP 	?C0134
?C0055:
;     if(key_value = Key_scan_func(KS1)){ logvalue(0xEC,(key_value+4), 1);   return (key_value+4);}
			; SOURCE LINE # 442
	MOV  	R7,#091H
	LCALL	_Key_scan_func
	MOV  	DPTR,#key_value?1242
	MOV  	A,R7
	MOVX 	@DPTR,A
	JZ   	?C0056
	MOVX 	A,@DPTR
	ADD  	A,#04H
	MOV  	R5,A
	MOV  	R3,#01H
	MOV  	R7,#0ECH
	LCALL	_logvalue
	MOV  	DPTR,#key_value?1242
	MOVX 	A,@DPTR
	ADD  	A,#04H
	MOV  	R7,A
	RET  	
?C0056:
;     if(key_value = Key_scan_func(KS2)){ logvalue(0xED,(key_value+8), 1);   return (key_value+8);}
			; SOURCE LINE # 443
	MOV  	R7,#0C1H
	LCALL	_Key_scan_func
	MOV  	DPTR,#key_value?1242
	MOV  	A,R7
	MOVX 	@DPTR,A
	JZ   	?C0057
	MOVX 	A,@DPTR
	ADD  	A,#08H
	MOV  	R5,A
	MOV  	R3,#01H
	MOV  	R7,#0EDH
	LCALL	_logvalue
	MOV  	DPTR,#key_value?1242
	MOVX 	A,@DPTR
	ADD  	A,#08H
	MOV  	R7,A
	RET  	
?C0057:
;     if(key_value = Key_scan_func(KS3)){ logvalue(0xEE,(key_value+12), 1);  return (key_value+12);} 
			; SOURCE LINE # 444
	MOV  	R7,#0D0H
	LCALL	_Key_scan_func
	MOV  	DPTR,#key_value?1242
	MOV  	A,R7
	MOVX 	@DPTR,A
	JZ   	?C0058
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R5,A
	MOV  	R3,#01H
	MOV  	R7,#0EEH
	LCALL	_logvalue
	MOV  	DPTR,#key_value?1242
	MOVX 	A,@DPTR
	ADD  	A,#0CH
	MOV  	R7,A
	RET  	
?C0058:
;     
;     return key_value;
			; SOURCE LINE # 446
?C0134:
	MOV  	DPTR,#key_value?1242
	MOVX 	A,@DPTR
	MOV  	R7,A
; }
			; SOURCE LINE # 447
?C0053:
	RET  	
; END OF Key24_Detect_GPIO

; 
; #if 0
; uint8 Key_Detect_GPIO(void)
; {
; 	uint8 keybuf[2];
; 	uint8 i, j, KeyTempCode;
; 
; 	keybuf[0] = 0;
; 	keybuf[1] = 0;
; 
; 	key_s0 = 0;
; 	key_s1 = 1;
; 	key_s2 = 1;
; 	key_s3 = 1;
; 
; 	i = 0;
; 	if(!key_r0)
; 		keybuf[i] |= 0x01;
; 	else if(!key_r1)
; 		keybuf[i] |= 0x02;
; 	else if(!key_r2)
; 		keybuf[i] |= 0x04;
; 	else if(!key_r3)
; 		keybuf[i] |= 0x08;
; 
; 	key_s0 = 1;
; 	key_s1 = 0;
; 	if(!key_r0)
; 		keybuf[i] |= 0x10;
; 	else if(!key_r1)
; 		keybuf[i] |= 0x20;
; 	else if(!key_r2)
; 		keybuf[i] |= 0x40;
; 	else if(!key_r3)
; 		keybuf[i] |= 0x80;
; 
; 	key_s1 = 1;
; 	key_s2 = 0;	
; 	i = 1;
; 	if(!key_r0)
; 		keybuf[i] |= 0x01;
; 	else if(!key_r1)
; 		keybuf[i] |= 0x02;
; 	else if(!key_r2)
; 		keybuf[i] |= 0x04;
; 	else if(!key_r3)
; 		keybuf[i] |= 0x08;
; 
; 	key_s2 = 1;
; 	key_s3 = 0;
; 	if(!key_r0)
; 		keybuf[i] |= 0x10;
; 	else if(!key_r1)
; 		keybuf[i] |= 0x20;
; 	else if(!key_r2)
; 		keybuf[i] |= 0x40;
; 	else if(!key_r3)
; 		keybuf[i] |= 0x80;
; 
; 	key_s0 = 0;
; 	key_s1 = 0;	
; 	key_s2 = 0;
; 	key_s3 = 0;
; 
; 	key_r0^=1;
; 
; 	KeyTempCode = 1;
; 	for(i=0;i<2;i++) 
; 	{
; 		for(j=0;j<8;j++)
; 		{
; 			if(keybuf[i]&0x01)
; 			{
; 				return (KeyTempCode);
; 			}
; 			keybuf[i] >>= 1;
; 			KeyTempCode++;
; 		}
; 			
; 	}
; 	return 0;
; }
; #endif
; 
; #define	CRC_CHECK_START	13
; #define	CRC_CHECK_STOP	(CRC_CHECK_START+11)
; uint8 Calc_CRC_Value(void){

	RSEG  ?PR?Calc_CRC_Value?MAIN
Calc_CRC_Value:
	USING	0
			; SOURCE LINE # 534
; 	uint8 i;
; 	uint8 sum_1;
; 	sum_1 = AdvPacket_2[CRC_CHECK_START];
			; SOURCE LINE # 537
	MOV  	DPTR,#AdvPacket_2+0DH
	MOVX 	A,@DPTR
	MOV  	R7,A
;---- Variable 'sum_1?1344' assigned to Register 'R7' ----
; 	for(i=(CRC_CHECK_START+1);i<CRC_CHECK_STOP;i++){
			; SOURCE LINE # 538
;---- Variable 'i?1343' assigned to Register 'R6' ----
	MOV  	R6,#0EH
?C0059:
	MOV  	A,R6
	CLR  	C
	SUBB 	A,#018H
	MOV  	A,#080H
	SUBB 	A,#080H
	JNC  	?C0060
; 		sum_1 += AdvPacket_2[i];
			; SOURCE LINE # 539
	MOV  	A,#LOW (AdvPacket_2)
	ADD  	A,R6
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,#HIGH (AdvPacket_2)
	MOV  	DPH,A
	MOVX 	A,@DPTR
	ADD  	A,R7
	MOV  	R7,A
; 	}
			; SOURCE LINE # 540
	INC  	R6
	SJMP 	?C0059
?C0060:
; 	return sum_1;
			; SOURCE LINE # 541
; }
			; SOURCE LINE # 542
	RET  	
; END OF Calc_CRC_Value

; 
; void Set_Common_com_Data(void){

	RSEG  ?PR?Set_Common_com_Data?MAIN
Set_Common_com_Data:
	USING	0
			; SOURCE LINE # 544
; 	Set_MacAddr();
			; SOURCE LINE # 545
	LCALL	Set_MacAddr
; 	AdvPacket_2[1] = Adv_Packet_Len;  //数据长度，定长  装载的数据长度  ,19+6+2 = 27
			; SOURCE LINE # 546
	MOV  	DPTR,#AdvPacket_2+01H
	MOV  	A,#01BH
	MOVX 	@DPTR,A
; 	
; 	AdvPacket_2[8] = 20;   // payload数据长度
			; SOURCE LINE # 548
	MOV  	DPTR,#AdvPacket_2+08H
	MOV  	A,#014H
	MOVX 	@DPTR,A
; 	AdvPacket_2[9] = 0x01;
			; SOURCE LINE # 549
	INC  	DPTR
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 	AdvPacket_2[10] = 0x04;
			; SOURCE LINE # 550
	INC  	DPTR
	MOV  	A,#04H
	MOVX 	@DPTR,A
; 	AdvPacket_2[11] = 0x11;
			; SOURCE LINE # 551
	INC  	DPTR
	MOV  	A,#011H
	MOVX 	@DPTR,A
; 	AdvPacket_2[12] = 0x07;   //
			; SOURCE LINE # 552
	INC  	DPTR
	MOV  	A,#07H
	MOVX 	@DPTR,A
; 	
; 	AdvPacket_2[13] = 0x00;    //company set,厂家码
			; SOURCE LINE # 554
	CLR  	A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	AdvPacket_2[14] = 0x10;    //遥控器，遥控器用0x10来识别
			; SOURCE LINE # 555
	INC  	DPTR
	MOV  	A,#010H
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 556
	RET  	
; END OF Set_Common_com_Data

; 
; void Set_Common_Tx_Data(void){

	RSEG  ?PR?Set_Common_Tx_Data?MAIN
Set_Common_Tx_Data:
	USING	0
			; SOURCE LINE # 558
; 	AdvPacket_2[22] = 0;
			; SOURCE LINE # 559
	CLR  	A
	MOV  	DPTR,#AdvPacket_2+016H
	MOVX 	@DPTR,A
;     
; 	SequenceNum_1 ++;
			; SOURCE LINE # 561
	MOV  	DPTR,#SequenceNum_1
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
; 
; 	AdvPacket_2[23] = SequenceNum_1;
			; SOURCE LINE # 563
	MOVX 	A,@DPTR
	MOV  	DPTR,#AdvPacket_2+017H
	MOVX 	@DPTR,A
; 	AdvPacket_2[24] = Calc_CRC_Value();
			; SOURCE LINE # 564
	LCALL	Calc_CRC_Value
	MOV  	DPTR,#AdvPacket_2+018H
	MOV  	A,R7
	MOVX 	@DPTR,A
; 	AdvPacket_2[25] = 0x00;
			; SOURCE LINE # 565
	CLR  	A
	INC  	DPTR
	MOVX 	@DPTR,A
; 	AdvPacket_2[26] = 0xAA;  //幸好在接收模块上只识别到0xAA
			; SOURCE LINE # 566
	INC  	DPTR
	MOV  	A,#0AAH
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 567
	RET  	
; END OF Set_Common_Tx_Data

; 
; 
; void ShortKey_PowerOn(void){

	RSEG  ?PR?ShortKey_PowerOn?MAIN
ShortKey_PowerOn:
	USING	0
			; SOURCE LINE # 570
;     loginfo("Pwon\r\n");
			; SOURCE LINE # 571
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_0)
	MOV  	R1,#LOW (?SC_0)
	LCALL	_loginfo
;     CurrentGroup_1[0] = Group_ALL;
			; SOURCE LINE # 572
	MOV  	DPTR,#CurrentGroup_1
	MOV  	A,#0FFH
	MOVX 	@DPTR,A
;     AdvPacket_2[15] = Group_ALL;    //组
			; SOURCE LINE # 573
	MOV  	DPTR,#AdvPacket_2+0FH
	MOVX 	@DPTR,A
;     AdvPacket_2[19] = BLE_CMD_onoff;    //on/off cmd
			; SOURCE LINE # 574
	MOV  	DPTR,#AdvPacket_2+013H
	MOV  	A,#014H
	MOVX 	@DPTR,A
;     AdvPacket_2[20] = CMD_turn_on;
			; SOURCE LINE # 575
	CLR  	A
	INC  	DPTR
	MOVX 	@DPTR,A
;     
; }
			; SOURCE LINE # 577
	RET  	
; END OF ShortKey_PowerOn

; void ShortKey_PowerOff(void){

	RSEG  ?PR?ShortKey_PowerOff?MAIN
ShortKey_PowerOff:
	USING	0
			; SOURCE LINE # 578
;     loginfo("Pwoff\r\n");
			; SOURCE LINE # 579
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_7)
	MOV  	R1,#LOW (?SC_7)
	LCALL	_loginfo
;     CurrentGroup_1[0] = Group_ALL;
			; SOURCE LINE # 580
	MOV  	DPTR,#CurrentGroup_1
	MOV  	A,#0FFH
	MOVX 	@DPTR,A
;     AdvPacket_2[15] = Group_ALL;    //组
			; SOURCE LINE # 581
	MOV  	DPTR,#AdvPacket_2+0FH
	MOVX 	@DPTR,A
;     AdvPacket_2[19] = BLE_CMD_onoff;    //on/off cmd
			; SOURCE LINE # 582
	MOV  	DPTR,#AdvPacket_2+013H
	MOV  	A,#014H
	MOVX 	@DPTR,A
;     AdvPacket_2[20] = CMD_turn_off;
			; SOURCE LINE # 583
	INC  	DPTR
	MOV  	A,#01H
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 584
	RET  	
; END OF ShortKey_PowerOff

; void ShortKey_E(void){

	RSEG  ?PR?ShortKey_E?MAIN
ShortKey_E:
	USING	0
			; SOURCE LINE # 585
;     loginfo("K_E\r\n");
			; SOURCE LINE # 586
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_15)
	MOV  	R1,#LOW (?SC_15)
	LJMP 	_loginfo
; END OF ShortKey_E

; 
; }
; void ShortKey_S_sub(void){

	RSEG  ?PR?ShortKey_S_sub?MAIN
ShortKey_S_sub:
	USING	0
			; SOURCE LINE # 589
;     loginfo("K_S sub\r\n");
			; SOURCE LINE # 590
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_21)
	MOV  	R1,#LOW (?SC_21)
	LJMP 	_loginfo
; END OF ShortKey_S_sub

; 
; }
; void ShortKey_S_add(void){

	RSEG  ?PR?ShortKey_S_add?MAIN
ShortKey_S_add:
	USING	0
			; SOURCE LINE # 593
;     loginfo("K_S add\r\n");
			; SOURCE LINE # 594
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_31)
	MOV  	R1,#LOW (?SC_31)
	LJMP 	_loginfo
; END OF ShortKey_S_add

; 
; }
; void ShortKey_White(void){

	RSEG  ?PR?ShortKey_White?MAIN
ShortKey_White:
	USING	0
			; SOURCE LINE # 597
;     loginfo("K_white\r\n");
			; SOURCE LINE # 598
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_41)
	MOV  	R1,#LOW (?SC_41)
	LJMP 	_loginfo
; END OF ShortKey_White

; }
; void ShortKey_Red(void){

	RSEG  ?PR?ShortKey_Red?MAIN
ShortKey_Red:
	USING	0
			; SOURCE LINE # 600
;     loginfo("K_red\r\n");
			; SOURCE LINE # 601
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_51)
	MOV  	R1,#LOW (?SC_51)
	LJMP 	_loginfo
; END OF ShortKey_Red

; 
; }
; void ShortKey_B_add(void){

	RSEG  ?PR?ShortKey_B_add?MAIN
ShortKey_B_add:
	USING	0
			; SOURCE LINE # 604
;     loginfo("K_b add\r\n");
			; SOURCE LINE # 605
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_59)
	MOV  	R1,#LOW (?SC_59)
	LJMP 	_loginfo
; END OF ShortKey_B_add

; 
; }
; void ShortKey_Yellow(void){

	RSEG  ?PR?ShortKey_Yellow?MAIN
ShortKey_Yellow:
	USING	0
			; SOURCE LINE # 608
;     loginfo("K_yellow\r\n");
			; SOURCE LINE # 609
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_69)
	MOV  	R1,#LOW (?SC_69)
	LJMP 	_loginfo
; END OF ShortKey_Yellow

; 
; }
; void ShortKey_Green(void){

	RSEG  ?PR?ShortKey_Green?MAIN
ShortKey_Green:
	USING	0
			; SOURCE LINE # 612
;     loginfo("K_green\r\n");
			; SOURCE LINE # 613
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_80)
	MOV  	R1,#LOW (?SC_80)
	LJMP 	_loginfo
; END OF ShortKey_Green

; 
; }
; void ShortKey_Scale(void){

	RSEG  ?PR?ShortKey_Scale?MAIN
ShortKey_Scale:
	USING	0
			; SOURCE LINE # 616
;     loginfo("K_scale\r\n");
			; SOURCE LINE # 617
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_90)
	MOV  	R1,#LOW (?SC_90)
	LJMP 	_loginfo
; END OF ShortKey_Scale

; 
; }
; void ShortKey_Color(void){

	RSEG  ?PR?ShortKey_Color?MAIN
ShortKey_Color:
	USING	0
			; SOURCE LINE # 620
;     loginfo("K_color\r\n");
			; SOURCE LINE # 621
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_100)
	MOV  	R1,#LOW (?SC_100)
	LJMP 	_loginfo
; END OF ShortKey_Color

; 
; }
; 
; void ShortKey_Blue(void){

	RSEG  ?PR?ShortKey_Blue?MAIN
ShortKey_Blue:
	USING	0
			; SOURCE LINE # 625
;     loginfo("K_blue\r\n");
			; SOURCE LINE # 626
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_110)
	MOV  	R1,#LOW (?SC_110)
	LJMP 	_loginfo
; END OF ShortKey_Blue

; 
; }
; void ShortKey_B_sub(void){

	RSEG  ?PR?ShortKey_B_sub?MAIN
ShortKey_B_sub:
	USING	0
			; SOURCE LINE # 629
;     loginfo("K_b sub\r\n");
			; SOURCE LINE # 630
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_119)
	MOV  	R1,#LOW (?SC_119)
	LJMP 	_loginfo
; END OF ShortKey_B_sub

; 
; }
; void ShortKey_M1(void){

	RSEG  ?PR?ShortKey_M1?MAIN
ShortKey_M1:
	USING	0
			; SOURCE LINE # 633
;     loginfo("K m1\r\n");
			; SOURCE LINE # 634
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_129)
	MOV  	R1,#LOW (?SC_129)
	LJMP 	_loginfo
; END OF ShortKey_M1

; 
; }
; void ShortKey_M2(void){

	RSEG  ?PR?ShortKey_M2?MAIN
ShortKey_M2:
	USING	0
			; SOURCE LINE # 637
;     loginfo("K m2\r\n");
			; SOURCE LINE # 638
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_136)
	MOV  	R1,#LOW (?SC_136)
	LJMP 	_loginfo
; END OF ShortKey_M2

; 
; }
; void ShortKey_M3(void){

	RSEG  ?PR?ShortKey_M3?MAIN
ShortKey_M3:
	USING	0
			; SOURCE LINE # 641
;     loginfo("K m3\r\n");
			; SOURCE LINE # 642
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_143)
	MOV  	R1,#LOW (?SC_143)
	LJMP 	_loginfo
; END OF ShortKey_M3

; 
; }
; void ShortKey_M4(void){

	RSEG  ?PR?ShortKey_M4?MAIN
ShortKey_M4:
	USING	0
			; SOURCE LINE # 645
;     loginfo("K m4\r\n");
			; SOURCE LINE # 646
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_150)
	MOV  	R1,#LOW (?SC_150)
	LJMP 	_loginfo
; END OF ShortKey_M4

; 
; }
; void ShortKey_M5(void){

	RSEG  ?PR?ShortKey_M5?MAIN
ShortKey_M5:
	USING	0
			; SOURCE LINE # 649
;     loginfo("K m5\r\n");
			; SOURCE LINE # 650
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_157)
	MOV  	R1,#LOW (?SC_157)
	LJMP 	_loginfo
; END OF ShortKey_M5

; 
; }
; void ShortKey_M6(void){

	RSEG  ?PR?ShortKey_M6?MAIN
ShortKey_M6:
	USING	0
			; SOURCE LINE # 653
;     loginfo("K m6\r\n");
			; SOURCE LINE # 654
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_164)
	MOV  	R1,#LOW (?SC_164)
	LJMP 	_loginfo
; END OF ShortKey_M6

; 
; }
; void ShortKey_M7(void){

	RSEG  ?PR?ShortKey_M7?MAIN
ShortKey_M7:
	USING	0
			; SOURCE LINE # 657
;     loginfo("K m7\r\n");
			; SOURCE LINE # 658
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_171)
	MOV  	R1,#LOW (?SC_171)
	LJMP 	_loginfo
; END OF ShortKey_M7

; 
; }
; void ShortKey_M8(void){

	RSEG  ?PR?ShortKey_M8?MAIN
ShortKey_M8:
	USING	0
			; SOURCE LINE # 661
;     loginfo("K m8\r\n");
			; SOURCE LINE # 662
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_178)
	MOV  	R1,#LOW (?SC_178)
	LJMP 	_loginfo
; END OF ShortKey_M8

; 
; }
; void ShortKey_M9(void){

	RSEG  ?PR?ShortKey_M9?MAIN
ShortKey_M9:
	USING	0
			; SOURCE LINE # 665
;     loginfo("K m9\r\n");
			; SOURCE LINE # 666
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_185)
	MOV  	R1,#LOW (?SC_185)
	LJMP 	_loginfo
; END OF ShortKey_M9

; 
; }
; 
; uint8 LongKey_Indentify(uint8 keyvalue){

	RSEG  ?PR?_LongKey_Indentify?MAIN
_LongKey_Indentify:
	USING	0
			; SOURCE LINE # 670
;---- Variable 'keyvalue?3945' assigned to Register 'R7' ----
;     if(keyvalue == SKEY_POWER_ON){
			; SOURCE LINE # 671
	MOV  	A,R7
	MOV  	R5,A
	MOV  	R4,#00H
	XRL  	A,#08H
	JNZ  	?C0088
;         return LKEY_POWER_ON;
			; SOURCE LINE # 672
	MOV  	R7,#019H
	RET  	
;     }
			; SOURCE LINE # 673
?C0088:
;     if(keyvalue == SKEY_POWER_OFF){
			; SOURCE LINE # 674
	MOV  	A,R5
	XRL  	A,#018H
	ORL  	A,R4
	JNZ  	?C0090
;         return LKEY_POWER_OFF;
			; SOURCE LINE # 675
	MOV  	R7,#01AH
	RET  	
;     }
			; SOURCE LINE # 676
?C0090:
;     if(keyvalue == SKEY_E){
			; SOURCE LINE # 677
	MOV  	A,R7
	MOV  	R5,A
	MOV  	R4,#00H
	XRL  	A,#014H
	JNZ  	?C0091
;         return LKEY_E;
			; SOURCE LINE # 678
	MOV  	R7,#01BH
	RET  	
;     }
			; SOURCE LINE # 679
?C0091:
;     if(keyvalue == SKEY_COLOR){
			; SOURCE LINE # 680
	MOV  	A,R5
	XRL  	A,#011H
	ORL  	A,R4
	JNZ  	?C0092
;         return LKEY_COLOR;
			; SOURCE LINE # 681
	MOV  	R7,#01CH
	RET  	
;     }
			; SOURCE LINE # 682
?C0092:
;     return keyvalue;
			; SOURCE LINE # 683
; }
			; SOURCE LINE # 684
?C0089:
	RET  	
; END OF _LongKey_Indentify

; 
; void LongKey_PowerOn(void){

	RSEG  ?PR?LongKey_PowerOn?MAIN
LongKey_PowerOn:
	USING	0
			; SOURCE LINE # 686
;     loginfo("LK pwon\r\n");
			; SOURCE LINE # 687
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_192)
	MOV  	R1,#LOW (?SC_192)
	LJMP 	_loginfo
; END OF LongKey_PowerOn

; }
; void LongKey_PowerOff(void){

	RSEG  ?PR?LongKey_PowerOff?MAIN
LongKey_PowerOff:
	USING	0
			; SOURCE LINE # 689
;     loginfo("LK pwoff\r\n");
			; SOURCE LINE # 690
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_202)
	MOV  	R1,#LOW (?SC_202)
	LCALL	_loginfo
;     CurrentGroup_1[0] = Group_ALL;
			; SOURCE LINE # 691
	MOV  	DPTR,#CurrentGroup_1
	MOV  	A,#0FFH
	MOVX 	@DPTR,A
;     AdvPacket_2[15] = Group_ALL;    //组
			; SOURCE LINE # 692
	MOV  	DPTR,#AdvPacket_2+0FH
	MOVX 	@DPTR,A
;     AdvPacket_2[19] = BLE_CMD_onoff;    //on/off cmd
			; SOURCE LINE # 693
	MOV  	DPTR,#AdvPacket_2+013H
	MOV  	A,#014H
	MOVX 	@DPTR,A
;     AdvPacket_2[20] = CMD_turn_off;  
			; SOURCE LINE # 694
	INC  	DPTR
	MOV  	A,#01H
	MOVX 	@DPTR,A
; 
; }
			; SOURCE LINE # 696
	RET  	
; END OF LongKey_PowerOff

; void LongKey_E(void){

	RSEG  ?PR?LongKey_E?MAIN
LongKey_E:
	USING	0
			; SOURCE LINE # 697
;     loginfo("LK e\r\n");
			; SOURCE LINE # 698
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_213)
	MOV  	R1,#LOW (?SC_213)
	LJMP 	_loginfo
; END OF LongKey_E

; 
; }
; void LongKey_Color(void){

	RSEG  ?PR?LongKey_Color?MAIN
LongKey_Color:
	USING	0
			; SOURCE LINE # 701
;     loginfo("LK cl\r\n");
			; SOURCE LINE # 702
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_220)
	MOV  	R1,#LOW (?SC_220)
	LJMP 	_loginfo
; END OF LongKey_Color

; 
; }
; 
; 
; code st_key_handle_map Key24_TBL[]={ 
;     {NO_KEY_PRESS,	NULL,},	// 0x0 
;     //短按键处理
;     
;     {SKEY_M3,      	 ShortKey_M3,},         // 1
;     {SKEY_YELLOW,    ShortKey_Yellow,},     // 2
;     {SKEY_M8,        ShortKey_M8,},         // 3
;     {SKEY_M1,        ShortKey_M1,},
;     {SKEY_B_SUB,     ShortKey_B_sub,},
;     {SKEY_S_ADD,     ShortKey_S_add,},
;     {SKEY_M6,        ShortKey_M6,},  //7
; 
;     {SKEY_POWER_ON,  ShortKey_PowerOn,},
;     {SKEY_SCALE,     ShortKey_Scale,},
;     {SKEY_RED,       ShortKey_Red,},  // 10
;     {SKEY_M5,        ShortKey_M5,},
;     {SKEY_S1,	     	 NULL,},	// 12
;     {SKEY_GREEN,     ShortKey_Green,},
;     {SKEY_WHITE,     ShortKey_White,},
;     {SKEY_M7,        ShortKey_M7,},
;     {SKEY_M9,        ShortKey_M9,}, //15
;     {SKEY_COLOR,     ShortKey_Color,},
;     {SKEY_S_SUB,     ShortKey_S_sub,},
;     {SKEY_M2,        ShortKey_M2,},
;     {SKEY_E,         ShortKey_E,},
;     {SKEY_BLUE,      ShortKey_Blue,}, //20
;     {SKEY_B_ADD,     ShortKey_B_add,},
;     {SKEY_M4,      	 ShortKey_M4,}, //22
;     {SKEY_POWER_OFF, ShortKey_PowerOff,}, //23
; 
;     {LKEY_POWER_ON,  LongKey_PowerOn,},
;     {LKEY_POWER_OFF, LongKey_PowerOff,},    
;     {LKEY_E,         LongKey_E,},
;     {LKEY_COLOR,     LongKey_Color}
; };
; 
; 
; //K_green   K_white  K_S add  K_color
; #define KEYRELEASE  0
; void Key_Scan(void){

	RSEG  ?PR?Key_Scan?MAIN
Key_Scan:
	USING	0
			; SOURCE LINE # 746
; 	uint8 inKey;
;     
;     inKey = Key24_Detect_GPIO();
			; SOURCE LINE # 749
	LCALL	Key24_Detect_GPIO
	MOV  	DPTR,#inKey?4446
	MOV  	A,R7
	MOVX 	@DPTR,A
;     if(inKey == KEYRELEASE){//按键释放
			; SOURCE LINE # 750
	JZ   	$ + 5H
	LJMP 	?C0097
;         if(KeyCode){
			; SOURCE LINE # 751
	MOV  	DPTR,#KeyCode
	MOVX 	A,@DPTR
	MOV  	R7,A
	JNZ  	$ + 5H
	LJMP 	?C0109
;             if((KeyCount >= 50) && (KeyCount < 1000))  //短按的释放
			; SOURCE LINE # 752
	MOV  	DPTR,#KeyCount
	MOVX 	A,@DPTR
	MOV  	R4,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	R5,A
	CLR  	C
	SUBB 	A,#032H
	MOV  	A,R4
	SUBB 	A,#00H
	JC   	?C0099
	MOV  	A,R5
	SUBB 	A,#0E8H
	MOV  	A,R4
	SUBB 	A,#03H
	JNC  	?C0099
;             {
			; SOURCE LINE # 753
;                 if(Key24_TBL[KeyCode].index == KeyCode){
			; SOURCE LINE # 754
	MOV  	DPTR,#KeyCode
	MOVX 	A,@DPTR
	MOV  	R6,A
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (Key24_TBL)
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,#HIGH (Key24_TBL)
	MOV  	DPH,A
	CLR  	A
	MOVC 	A,@A+DPTR
	CJNE 	A,AR6,?C0100
;                     Key24_TBL[KeyCode].handle();
			; SOURCE LINE # 755
	MOV  	A,R7
;                 }else{
			; SOURCE LINE # 756
	SJMP 	?C0135
?C0100:
;                     //logvalue(0xAA,KeyCode, Key24_TBL[KeyCode].index); 
;                     loginfo("Kerr");
			; SOURCE LINE # 758
	MOV  	R3,#0FFH
	MOV  	R2,#HIGH (?SC_228)
	MOV  	R1,#LOW (?SC_228)
	LCALL	_loginfo
;                 }
			; SOURCE LINE # 759
;             }else if(KeyCount > 1200){//长按按键
			; SOURCE LINE # 760
	SJMP 	?C0102
?C0099:
	SETB 	C
	MOV  	DPTR,#KeyCount+01H
	MOVX 	A,@DPTR
	SUBB 	A,#0B0H
	MOV  	DPTR,#KeyCount
	MOVX 	A,@DPTR
	SUBB 	A,#04H
	JC   	?C0102
;                 if(Key24_TBL[KeyCode].index == KeyCode){
			; SOURCE LINE # 761
	MOV  	DPTR,#KeyCode
	MOVX 	A,@DPTR
	MOV  	R7,A
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (Key24_TBL)
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,#HIGH (Key24_TBL)
	MOV  	DPH,A
	CLR  	A
	MOVC 	A,@A+DPTR
	CJNE 	A,AR7,?C0102
;                    Key24_TBL[KeyCode].handle();
			; SOURCE LINE # 762
	MOV  	DPTR,#KeyCode
	MOVX 	A,@DPTR
?C0135:
	ADD  	A,ACC
	ADD  	A,ACC
	ADD  	A,#LOW (Key24_TBL+01H)
	MOV  	DPL,A
	CLR  	A
	ADDC 	A,#HIGH (Key24_TBL+01H)
	MOV  	DPH,A
	MOV  	A,#01H
	MOVC 	A,@A+DPTR
	MOV  	R2,A
	MOV  	A,#02H
	MOVC 	A,@A+DPTR
	MOV  	R1,A
	LCALL	?C?ICALL
;                 }
			; SOURCE LINE # 763
;             }
			; SOURCE LINE # 764
?C0102:
;             
;             adv_flag = 1 ;
			; SOURCE LINE # 766
	SETB 	adv_flag
;             KeyCode = 0;
			; SOURCE LINE # 767
	CLR  	A
;         }
			; SOURCE LINE # 768
;     }else{//按键
			; SOURCE LINE # 769
	SJMP 	?C0136
?C0097:
;         if(KeyCode == 0){
			; SOURCE LINE # 770
	MOV  	DPTR,#KeyCode
	MOVX 	A,@DPTR
	JNZ  	?C0106
;             KeyCount = 0;
			; SOURCE LINE # 771
	MOV  	DPTR,#KeyCount
	MOVX 	@DPTR,A
	INC  	DPTR
	MOVX 	@DPTR,A
;         }
			; SOURCE LINE # 772
?C0106:
;         
;         if(KeyCount > 1000){
			; SOURCE LINE # 774
	SETB 	C
	MOV  	DPTR,#KeyCount+01H
	MOVX 	A,@DPTR
	SUBB 	A,#0E8H
	MOV  	DPTR,#KeyCount
	MOVX 	A,@DPTR
	SUBB 	A,#03H
	MOV  	DPTR,#inKey?4446
	MOVX 	A,@DPTR
	JC   	?C0107
;             KeyCode = LongKey_Indentify(inKey);
			; SOURCE LINE # 775
	MOV  	R7,A
	LCALL	_LongKey_Indentify
	MOV  	DPTR,#KeyCode
	MOV  	A,R7
	MOVX 	@DPTR,A
;         }else{
			; SOURCE LINE # 776
	RET  	
?C0107:
;             KeyCode = inKey;
			; SOURCE LINE # 777
?C0136:
	MOV  	DPTR,#KeyCode
	MOVX 	@DPTR,A
;         }
			; SOURCE LINE # 778
; #if 0
; 		if(KeyCount < 10000){	
; 			KeyCount++;	
; 		}else{
; 			KeyCount = LONG_CNT+1;
; 		}
; #endif        
;     }
			; SOURCE LINE # 786
; }
			; SOURCE LINE # 787
?C0109:
	RET  	
; END OF Key_Scan

; 
; #if 0
; void Key_Scan_old(void)
; {
; 	uint8 inKey;
; 	uint8 KeyMode = 0;
; 	uint8 newKey;
; 	newKey=HAL_KEY_NO_KEY;
; 	inKey = Key_Detect_GPIO();  //读取按键值
; 	short_long_touch_flag = 0;
; 	if(inKey != KeyCode)
; 	{
; 		if(KeyCode)
; 		{
;       		Close_FuncLED();
; 			if((KeyCount >= SHORT_CNT) && (KeyCount < LONG_CNT))  //短按的释放
; 			{
; 				KeyMode = KEY_PUSH_UP;  //释放按键
; 				newKey  = Key_TBL[KeyCode];
; 				switch(newKey)
; 				{
;                     case HAL_KEY_POWER_ON:    // all on/off
; 					case HAL_KEY_POWER_OFF:
;                         CurrentGroup_1[0] = Group_ALL;
;                         AdvPacket_2[15] = Group_ALL;    //组
; 						AdvPacket_2[19] = BLE_CMD_onoff;    //on/off cmd
;                         if(newKey == HAL_KEY_POWER_ON){  //on
;                             AdvPacket_2[20] = CMD_turn_on;
;                         }else if(newKey == HAL_KEY_POWER_OFF){
;                         	AdvPacket_2[20] = CMD_turn_off;  
;                         }
; 						goto exit_0;
; 						break;  
; 
;                    case HAL_KEY_POWER_OFF1:  //小夜灯 -> 中性光 
;                     AdvPacket_2[15] = CurrentGroup_1[0];
; 				    AdvPacket_2[19] = cmd_setcw_mode;	//on/off cmd
; 				    AdvPacket_2[20] = 255; //打开
; 				    AdvPacket_2[21] = 255; //打开
; 				    goto exit_2;
; 					//AdvPacket_2[15] = CurrentGroup_1[0];
; 					//AdvPacket_2[19] = cmd_cw_low_set;	//on/off cmd
; 					//AdvPacket_2[20] = 0; //打开
;                     //goto exit_0;
; 						break;
;                         
; 					//case HAL_KEY_POWER_ON1:   //在长条形中是小夜灯
; 					case HAL_KEY_POWER_ON2:  // // 开1 //  休闲  -> 定时
; 					    AdvPacket_2[15] = CurrentGroup_1[0];
; 					    AdvPacket_2[19] = cmd_time_set;	//on/off cmd
; 					    AdvPacket_2[20] = DingShing_Time; //打开
; 					    //AdvPacket_2[21] = 0x0f; //打开
; 						//CurrentGroup_1[0] = Group_One;
; 						//AdvPacket_2[15] = CurrentGroup_1[0];
; 						//AdvPacket_2[19] = BLE_CMD_onoff;	//on/off cmd
; 						//AdvPacket_2[20] = CMD_turn_on; //打开
; 						goto exit_0;
; 						break;
; 					//组2开
; 					//case HAL_KEY_POWER_ON2:
; 					 case HAL_KEY_POWER_OFF2:  //   开2   // 阅读  -> 小夜灯
; 					    AdvPacket_2[15] = CurrentGroup_1[0];
; 					    AdvPacket_2[19] = cmd_setcw_mode;	//on/off cmd
; 					    AdvPacket_2[20] = 15; //打开
; 					    AdvPacket_2[21] = 15; //打开
; 						//CurrentGroup_1[0] = Group_Two;
; 						//AdvPacket_2[15] = CurrentGroup_1[0];
; 						//AdvPacket_2[19] = BLE_CMD_onoff;	//on/off cmd
; 						//AdvPacket_2[20] = CMD_turn_on; //打开
; 						goto exit_2;
; 						break;	
;                  
;                     
; 					case HAL_KEY_POWER_ON3:    // 关1      学习   ->  暖光
; 					    AdvPacket_2[15] = CurrentGroup_1[0];
; 					    AdvPacket_2[19] = cmd_setcw_mode;	//on/off cmd
; 					    AdvPacket_2[20] = 0; //打开
; 					    AdvPacket_2[21] = 255; //打开
;                         goto exit_2;
; 						break;
; 					//case HAL_KEY_POWER_OFF2:
; 					 case HAL_KEY_POWER_OFF3:  // 关2      工作   ->  白光
;                         AdvPacket_2[15] = CurrentGroup_1[0];
; 					    AdvPacket_2[19] = cmd_setcw_mode;	//on/off cmd
; 					    AdvPacket_2[20] = 255; //打开
; 					    AdvPacket_2[21] = 0; //打开
;                         goto exit_2;
; 						break;	
;   
;                     case HAL_KEY_BRIGHT_UP:
;                     case HAL_KEY_BRIGHT_DOWN:
; 						AdvPacket_2[15] = CurrentGroup_1[0];//组号  off时，不切换组，只对当前操作发组号
; 						if(newKey==HAL_KEY_BRIGHT_UP)
; 							AdvPacket_2[19] = cmd_light_inc_set;	//亮度
; 						else if(newKey==HAL_KEY_BRIGHT_DOWN)
; 							AdvPacket_2[19] = cmd_light_dec_set;	//亮度
; 						goto exit_0;
; 						break;
;                     case HAL_KEY_TEMP_DOWN:
;                     case HAL_KEY_TEMP_UP:
; 						AdvPacket_2[15] = CurrentGroup_1[0];//组号  off时，不切换组，只对当前操作发组号
; 						if(newKey==HAL_KEY_TEMP_UP)
; 							AdvPacket_2[19] = cmd_temp_inc_set;	//色温
; 						else if(newKey==HAL_KEY_TEMP_DOWN)
; 							AdvPacket_2[19] = cmd_temp_dec_set;	//色温
; 
; 						AdvPacket_2[20] = 0x00;
; 					exit_0:
; 						fen_Duan = 0;
; 						rgb_static_dynamic = 0;
; 					//exit_1:
; 						AdvPacket_2[21] = 0x00;
;                     exit_2:
; 						short_long_touch_flag = 1;
; 						AdvPacket_2[22] = 0x00;
; 						SequenceNum_inc_1 = 0;
;                         break;
; 					default:
; 						{
;                         KeyMode = 0 ;
;                         newKey = 0 ;
; 						break;
; 						}
; 				}			
; 			}
; 			else if(KeyCount > LONG_CNT){   //长按的释放
; 				KeyMode = KEY_PUSH_UP;  //释放按键
; 				newKey  = Key_TBL[KeyCode];
; 				long_key_value_tempp = 0;  //长按只要释放了，就算重新按键
; 				SequenceNum_1++;
; 				switch(newKey)
; 				{
;                     case HAL_KEY_BRIGHT_UP:
;                     case HAL_KEY_BRIGHT_DOWN:
;                     case HAL_KEY_TEMP_DOWN:
;                     case HAL_KEY_TEMP_UP:
; 						short_long_touch_flag = 3;
; 						long_key_value_temp = 0;
; 						AdvPacket_2[15] = CurrentGroup_1[0];			//组号  off时，不切换组，只对当前操作发组号
; 						AdvPacket_2[19] = cmd_light_temp_change_stop;	//停止变化
; 						AdvPacket_2[21] = 0x00;
; 						AdvPacket_2[22] = 0x00;
; 						SequenceNum_inc_1 = 0;
; 						break;
; 				}
; 			}
; 		}
; 		KeyCode = inKey;
; 		KeyCount = 0;
; 		longCount_scale = 0;
;         wIdleTime = 0;
;         KeyCode1 = 0;
; 	}
; 	else if(KeyCode)
; 	{
; 		if(KeyCount < 10000){	
; 			KeyCount++;	
; 		}else{
; 			KeyCount = LONG_CNT+1;
; 		}
; 			
;         if(KeyCount == SHORT_CNT){
;             Open_FuncLED();
;         }
; 
;         if(KeyCount >= LONG_CNT_ADD){
;             KeyCount = LONG_CNT+1; 
;             KeyMode = KEY_PUSH_LONG;
; 			newKey = Key_TBL[KeyCode];
;              switch(newKey){
; 
;                 case HAL_KEY_BRIGHT_UP:
;                 case HAL_KEY_BRIGHT_DOWN:
; 					AdvPacket_2[15] = CurrentGroup_1[0];//组号  off时，不切换组，只对当前操作发组号
; 					if(newKey==HAL_KEY_BRIGHT_UP)
; 						AdvPacket_2[19] = cmd_light_inc_set;	//亮度长加
; 					else if(newKey==HAL_KEY_BRIGHT_DOWN)
; 						AdvPacket_2[19] = cmd_light_dec_set;	//亮度长减
; 					AdvPacket_2[20] = 0x00;
; 					short_long_touch_flag = 2;
; 					AdvPacket_2[21] = 0x00;
; 					AdvPacket_2[22] = 0x00;	
; 					break;
;                     
;                 case HAL_KEY_TEMP_DOWN:
;                 case HAL_KEY_TEMP_UP:
; 						AdvPacket_2[15] = CurrentGroup_1[0];//组号  off时，不切换组，只对当前操作发组号
; 						if(newKey==HAL_KEY_TEMP_UP)
; 							AdvPacket_2[19] = cmd_temp_inc_set;	//色温长增
; 						else if(newKey==HAL_KEY_TEMP_DOWN)
; 							AdvPacket_2[19] = cmd_temp_dec_set;	//色温长减
; 						AdvPacket_2[20] = 0x00;
; 						short_long_touch_flag = 2;
; 						AdvPacket_2[21] = 0x00;
; 						AdvPacket_2[22] = 0x00;
;                     break;
;                 
;                 default:	
; 					newKey  = HAL_KEY_NO_KEY;
;                     KeyMode = 0;
; 				break;   
;              }
;             
;         }
; 
; 		
; 		if(KeyCount == LONG_CNT)	// long key
; 		{
; 			longCount_scale++;
; 			if(longCount_scale>=Long_CNT_SCALE){
; 				longCount_scale = 0;
; 			}
; 			KeyMode = KEY_PUSH_LONG;
; 			newKey = Key_TBL[KeyCode];
; 			{
;             switch(newKey)
; 			{
;                 case HAL_KEY_POWER_ON1:
; 					
; 						CurrentGroup_1[0] =  Group_One;
; 
; 						AdvPacket_2[15] = Group_ALL;//组号  off时，不切换组，只对当前操作发组号		
; 						AdvPacket_2[19] = cmd_team_set; //组设置命令
; 						AdvPacket_2[20] = CurrentGroup_1[0];
; 						short_long_touch_flag = 2;
; 					    AdvPacket_2[21] = 0x00;
; 					    AdvPacket_2[22] = 0x00;						
; 				   		break;
; 												
;                 case HAL_KEY_BRIGHT_UP:
;                 case HAL_KEY_BRIGHT_DOWN:
; 					AdvPacket_2[15] = CurrentGroup_1[0];//组号  off时，不切换组，只对当前操作发组号
; 					if(newKey==HAL_KEY_BRIGHT_UP)
; 						AdvPacket_2[19] = cmd_light_inc_set;	//亮度长加
; 					else if(newKey==HAL_KEY_BRIGHT_DOWN)
; 						AdvPacket_2[19] = cmd_light_dec_set;	//亮度长减
; 					AdvPacket_2[20] = 0x00;
; 					short_long_touch_flag = 2;
; 					AdvPacket_2[21] = 0x00;
; 					AdvPacket_2[22] = 0x00;					
; 					break;
;                 case HAL_KEY_TEMP_DOWN:
;                 case HAL_KEY_TEMP_UP:
; 					AdvPacket_2[15] = CurrentGroup_1[0];//组号  off时，不切换组，只对当前操作发组号
; 					if(newKey==HAL_KEY_TEMP_UP)
; 						AdvPacket_2[19] = cmd_temp_inc_set;	//色温长增
; 					else if(newKey==HAL_KEY_TEMP_DOWN)
; 						AdvPacket_2[19] = cmd_temp_dec_set;	//色温长减
; 					AdvPacket_2[20] = 0x00;
; 
; 					short_long_touch_flag = 2;
; 					AdvPacket_2[21] = 0x00;
; 					AdvPacket_2[22] = 0x00;	
;                     break;
;                 case HAL_KEY_POWER_ON:
; 					CurrentGroup_1[0] =  Group_ALL;
; 					AdvPacket_2[15] = Group_ALL;//组号  off时，不切换组，只对当前操作发组号
; 					AdvPacket_2[19] = cmd_team_set; //组设置命令
; 					AdvPacket_2[20] = Group_ALL;
; 					short_long_touch_flag = 2;
; 					AdvPacket_2[21] = 0x00;
; 					AdvPacket_2[22] = 0x00;	
;                     break;
; 				case HAL_KEY_POWER_OFF:
; 					AdvPacket_2[15] = Group_ALL;//组号  off时，不切换组，只对当前操作发组号
; 					AdvPacket_2[19] = cmd_dissolve_set; //组设置命令
; 					AdvPacket_2[20] = Group_ALL;
; 					short_long_touch_flag = 2;
; 					AdvPacket_2[21] = 0x00;
; 					AdvPacket_2[22] = 0x00;						
; 				    break;
; 				default:	
; 					newKey  = HAL_KEY_NO_KEY;
;                     KeyMode = 0;
; 				break;
; 			}	
; 			}
; 		}		
; 	} 
; 
; 	if((newKey != HAL_KEY_NO_KEY)&&(short_long_touch_flag!=0))
; 	{
; 		Set_Common_Tx_Data(); //设置一些公用的Tx数据
;         adv_flag = 1 ;
;         adv_flag_count = 0;
; 		tx_data_seted = 1;
; 		rf_encode_37 = 0;
; 		rf_encode_38 = 0;
; 		rf_encode_39 = 0;
; 		rf_encode_state = 0;
; 	}
; }
; #endif
; 
; void TX_CMD_USE_BLE_mode(void)

	RSEG  ?PR?TX_CMD_USE_BLE_mode?MAIN
TX_CMD_USE_BLE_mode:
	USING	0
			; SOURCE LINE # 1082
; {  //使用BLE方式发码
			; SOURCE LINE # 1083
; 	//三个通道约3ms
; 	/* 在BLE三个广播信道中发送BLE Packet */
; 	++adv_flag_count;
			; SOURCE LINE # 1086
	MOV  	DPTR,#adv_flag_count
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
; 	if( adv_flag_count > Tx_Resend_Times){  //发15次
			; SOURCE LINE # 1087
	MOVX 	A,@DPTR
	SETB 	C
	SUBB 	A,#0C8H
	MOV  	A,#080H
	SUBB 	A,#080H
	JC   	?C0110
; 		long_key_value_tempp = long_key_value_temp;//用于判断本次的长按与上一次的长按键是否一致。
			; SOURCE LINE # 1088
	MOV  	DPTR,#long_key_value_temp
	MOVX 	A,@DPTR
	MOV  	DPTR,#long_key_value_tempp
	MOVX 	@DPTR,A
; 		long_key_value_temp = 0;
			; SOURCE LINE # 1089
	CLR  	A
	MOV  	DPTR,#long_key_value_temp
	MOVX 	@DPTR,A
; 		adv_flag = 0;
			; SOURCE LINE # 1090
	CLR  	adv_flag
; 		adv_flag_count = 0;
			; SOURCE LINE # 1091
	MOV  	DPTR,#adv_flag_count
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1092
?C0110:
; 	
; 	RF_TxLen_CH3789 = 32;
			; SOURCE LINE # 1094
	MOV  	DPTR,#RF_TxLen_CH3789
	MOV  	A,#020H
	MOVX 	@DPTR,A
; 	//三个通道发一次的时间约2ms,每4ms发一个轮回，则不会有冲突
; 	//一个通道发一次的时间约800us
; 	if(rf_encode_37  == 1){
			; SOURCE LINE # 1097
	JNB  	rf_encode_37,?C0111
; 		memcpy(&Payload_demo[0],&RF_TxBuf_CH37[0],RF_TxLen_CH3789);
			; SOURCE LINE # 1098
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	R0,#LOW (Payload_demo)
	MOV  	R4,#HIGH (Payload_demo)
	MOV  	R5,#01H
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH37)
	MOV  	R1,#LOW (RF_TxBuf_CH37)
	LCALL	?C?COPY
; 		RF_Set_Chn(2);
			; SOURCE LINE # 1099
	MOV  	DPTR,#0885H
	MOV  	A,#02H
	MOVX 	@DPTR,A
	MOV  	DPTR,#08D2H
	MOV  	A,#0F0H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#04AH
	MOVX 	@DPTR,A
; 		RF_TXNoAck(Payload_demo, RF_TxLen_CH3789);
			; SOURCE LINE # 1100
	MOV  	R3,#01H
	MOV  	R2,#HIGH (Payload_demo)
	MOV  	R1,#LOW (Payload_demo)
	MOV  	DPTR,#RF_TxLen_CH3789
	MOVX 	A,@DPTR
	MOV  	R5,A
	LCALL	_RF_TXNoAck
?C0112:
; 		while(RF_TxFlag==0);
			; SOURCE LINE # 1101
	MOV  	DPTR,#RF_TxFlag
	MOVX 	A,@DPTR
	JZ   	?C0112
; 		RF_TxFlag=0;
			; SOURCE LINE # 1102
	CLR  	A
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1103
?C0111:
; 	if(rf_encode_38  == 1){	
			; SOURCE LINE # 1104
	JNB  	rf_encode_38,?C0114
; 		memcpy(&Payload_demo[0],&RF_TxBuf_CH38[0],RF_TxLen_CH3789);
			; SOURCE LINE # 1105
	MOV  	DPTR,#RF_TxLen_CH3789
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	R0,#LOW (Payload_demo)
	MOV  	R4,#HIGH (Payload_demo)
	MOV  	R5,#01H
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH38)
	MOV  	R1,#LOW (RF_TxBuf_CH38)
	LCALL	?C?COPY
; 		RF_Set_Chn(26);
			; SOURCE LINE # 1106
	MOV  	DPTR,#0885H
	MOV  	A,#01AH
	MOVX 	@DPTR,A
	MOV  	DPTR,#08D2H
	MOV  	A,#030H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#04AH
	MOVX 	@DPTR,A
; 		RF_TXNoAck(Payload_demo, RF_TxLen_CH3789);
			; SOURCE LINE # 1107
	MOV  	R3,#01H
	MOV  	R2,#HIGH (Payload_demo)
	MOV  	R1,#LOW (Payload_demo)
	MOV  	DPTR,#RF_TxLen_CH3789
	MOVX 	A,@DPTR
	MOV  	R5,A
	LCALL	_RF_TXNoAck
?C0115:
; 		while(RF_TxFlag==0);
			; SOURCE LINE # 1108
	MOV  	DPTR,#RF_TxFlag
	MOVX 	A,@DPTR
	JZ   	?C0115
; 		RF_TxFlag=0;
			; SOURCE LINE # 1109
	CLR  	A
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1110
?C0114:
; 	if(rf_encode_39  == 1){
			; SOURCE LINE # 1111
	JNB  	rf_encode_39,?C0120
; 		memcpy(&Payload_demo[0],&RF_TxBuf_CH39[0],RF_TxLen_CH3789);
			; SOURCE LINE # 1112
	MOV  	DPTR,#RF_TxLen_CH3789
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	R6,#00H
	MOV  	R0,#LOW (Payload_demo)
	MOV  	R4,#HIGH (Payload_demo)
	MOV  	R5,#01H
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH39)
	MOV  	R1,#LOW (RF_TxBuf_CH39)
	LCALL	?C?COPY
; 		RF_Set_Chn(80);
			; SOURCE LINE # 1113
	MOV  	DPTR,#0885H
	MOV  	A,#050H
	MOVX 	@DPTR,A
	MOV  	DPTR,#08D2H
	MOV  	A,#080H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#048H
	MOVX 	@DPTR,A
; 		RF_TXNoAck(Payload_demo, RF_TxLen_CH3789);
			; SOURCE LINE # 1114
	MOV  	R3,#01H
	MOV  	R2,#HIGH (Payload_demo)
	MOV  	R1,#LOW (Payload_demo)
	MOV  	DPTR,#RF_TxLen_CH3789
	MOVX 	A,@DPTR
	MOV  	R5,A
	LCALL	_RF_TXNoAck
?C0118:
; 		while(RF_TxFlag==0);
			; SOURCE LINE # 1115
	MOV  	DPTR,#RF_TxFlag
	MOVX 	A,@DPTR
	JZ   	?C0118
; 		RF_TxFlag=0;
			; SOURCE LINE # 1116
	CLR  	A
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 1117
; }
			; SOURCE LINE # 1118
?C0120:
	RET  	
; END OF TX_CMD_USE_BLE_mode

; 
; void Get_MacAddr(void){   //从IC的寄存器中获取 mac地址

	RSEG  ?PR?Get_MacAddr?MAIN
Get_MacAddr:
			; SOURCE LINE # 1120
;    // SrcAddr_1[4] = ID4;
; 	SrcAddr_1[3] = ID3;
			; SOURCE LINE # 1122
	MOV  	DPTR,#SrcAddr_1+03H
	MOV  	A,#022H
	MOVX 	@DPTR,A
; 	SrcAddr_1[2] = ID2;
			; SOURCE LINE # 1123
	MOV  	DPTR,#SrcAddr_1+02H
	MOV  	A,#033H
	MOVX 	@DPTR,A
;     SrcAddr_1[1] = ID1;
			; SOURCE LINE # 1124
	MOV  	DPTR,#SrcAddr_1+01H
	MOV  	A,#044H
	MOVX 	@DPTR,A
; 	SrcAddr_1[0] = ID0;
			; SOURCE LINE # 1125
	MOV  	DPTR,#SrcAddr_1
	MOV  	A,#055H
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 1126
	RET  	
; END OF Get_MacAddr

; 
; void Set_MacAddr(void){

	RSEG  ?PR?Set_MacAddr?MAIN
Set_MacAddr:
	USING	0
			; SOURCE LINE # 1128
;     AdvPacket_2[2] = SrcAddr_1[0];
			; SOURCE LINE # 1129
	MOV  	DPTR,#SrcAddr_1
	MOVX 	A,@DPTR
	MOV  	R7,A
	MOV  	DPTR,#AdvPacket_2+02H
	MOVX 	@DPTR,A
;     AdvPacket_2[3] = SrcAddr_1[1];
			; SOURCE LINE # 1130
	MOV  	DPTR,#SrcAddr_1+01H
	MOVX 	A,@DPTR
	MOV  	R6,A
	MOV  	DPTR,#AdvPacket_2+03H
	MOVX 	@DPTR,A
;     AdvPacket_2[4] = SrcAddr_1[2];
			; SOURCE LINE # 1131
	MOV  	DPTR,#SrcAddr_1+02H
	MOVX 	A,@DPTR
	MOV  	R5,A
	MOV  	DPTR,#AdvPacket_2+04H
	MOVX 	@DPTR,A
;     AdvPacket_2[5] = SrcAddr_1[3];
			; SOURCE LINE # 1132
	MOV  	DPTR,#SrcAddr_1+03H
	MOVX 	A,@DPTR
	MOV  	DPTR,#AdvPacket_2+05H
	MOVX 	@DPTR,A
;     AdvPacket_2[6] = 0;//SrcAddr_1[4];  //原来BLE包需要的数据
			; SOURCE LINE # 1133
	CLR  	A
	INC  	DPTR
	MOVX 	@DPTR,A
; 
;     AdvPacket_2[16] = SrcAddr_1[0];  //ID的LSB ，1586从数据包抓取的mac地址
			; SOURCE LINE # 1135
	MOV  	DPTR,#AdvPacket_2+010H
	MOV  	A,R7
	MOVX 	@DPTR,A
;     AdvPacket_2[17] = SrcAddr_1[1];
			; SOURCE LINE # 1136
	INC  	DPTR
	MOV  	A,R6
	MOVX 	@DPTR,A
;     AdvPacket_2[18] = SrcAddr_1[2];
			; SOURCE LINE # 1137
	INC  	DPTR
	MOV  	A,R5
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 1138
	RET  	
; END OF Set_MacAddr

; void Power_On_Init(void){

	RSEG  ?PR?Power_On_Init?MAIN
Power_On_Init:
	USING	0
			; SOURCE LINE # 1139
;     uint8 i = 10;
			; SOURCE LINE # 1140
	MOV  	DPTR,#i?4847
	MOV  	A,#0AH
	MOVX 	@DPTR,A
; 	EA = 0;
			; SOURCE LINE # 1141
	CLR  	EA
; 	InitSysTimer();
			; SOURCE LINE # 1142
	LCALL	InitSysTimer
; 	Sys_set_1MHZ_rate();
			; SOURCE LINE # 1143
	LCALL	Sys_set_1MHZ_rate
; 	EA = 1;
			; SOURCE LINE # 1144
	SETB 	EA
; 
; #if UART_ENABLE
;     UartConfig(BAUD);
			; SOURCE LINE # 1147
	MOV  	R7,#080H
	MOV  	R6,#025H
	LCALL	_UartConfig
;     WaitUs(60000);	
			; SOURCE LINE # 1148
	MOV  	R7,#060H
	MOV  	R6,#0EAH
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
; #endif
; 
;     BlePacketDeductive( RF_TxBuf_CH37, AdvPacket_2, 29, 37);
			; SOURCE LINE # 1151
	MOV  	DPTR,#?_BlePacketDeductive?BYTE+03H
	MOV  	A,#01H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#HIGH (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#LOW (AdvPacket_2)
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#01DH
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#025H
	MOVX 	@DPTR,A
	MOV  	R3,#01H
	MOV  	R2,#HIGH (RF_TxBuf_CH37)
	MOV  	R1,#LOW (RF_TxBuf_CH37)
	LCALL	_BlePacketDeductive
; #if UART_ENABLE
;     uart_data_send[0] = '2';
			; SOURCE LINE # 1153
	MOV  	DPTR,#uart_data_send
	MOV  	A,#032H
	MOVX 	@DPTR,A
;     uart_data_send[1] = '4';
			; SOURCE LINE # 1154
	INC  	DPTR
	MOV  	A,#034H
	MOVX 	@DPTR,A
;     uart_data_send[2] = '6';
			; SOURCE LINE # 1155
	INC  	DPTR
	MOV  	A,#036H
	MOVX 	@DPTR,A
;     uart_data_send[3] = '1';
			; SOURCE LINE # 1156
	INC  	DPTR
	MOV  	A,#031H
	MOVX 	@DPTR,A
;     uart_data_send[4] = 'i';
			; SOURCE LINE # 1157
	INC  	DPTR
	MOV  	A,#069H
	MOVX 	@DPTR,A
;     uart_data_send[5] = 'n';
			; SOURCE LINE # 1158
	INC  	DPTR
	MOV  	A,#06EH
	MOVX 	@DPTR,A
;     uart_data_send[6] = 'i';
			; SOURCE LINE # 1159
	INC  	DPTR
	MOV  	A,#069H
	MOVX 	@DPTR,A
;     uart_data_send[7] = 't';
			; SOURCE LINE # 1160
	INC  	DPTR
	MOV  	A,#074H
	MOVX 	@DPTR,A
;     uart_data_send[8] = '\n';
			; SOURCE LINE # 1161
	INC  	DPTR
	MOV  	A,#0AH
	MOVX 	@DPTR,A
;     uart_data_send[9] = '\r';
			; SOURCE LINE # 1162
	INC  	DPTR
	MOV  	A,#0DH
	MOVX 	@DPTR,A
;     driver_uart_send_start(9);
			; SOURCE LINE # 1163
	MOV  	R7,#09H
	LCALL	_driver_uart_send_start
;     WaitUs(60000); 
			; SOURCE LINE # 1164
	MOV  	R7,#060H
	MOV  	R6,#0EAH
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
; #if 0    
; 	while(i){ //
; 	   // driver_uart_send_start(9);
;        //  WaitUs(60000); 
;        
; 		WaitUs(10); 
;         Key_Scan();
; 	}
; #endif
; 
; #else
;     PALT1_CLB(BIT(2)); // 除能串口脚  
; #endif
;     
;     Delay_ms(1);
			; SOURCE LINE # 1179
	MOV  	R7,#01H
	MOV  	R6,#00H
	LCALL	_Delay_ms
;     
;     FuncLED_Init();
			; SOURCE LINE # 1181
	LCALL	FuncLED_Init
; 	CurrentGroup_1[0] = Group_ALL;
			; SOURCE LINE # 1182
	MOV  	DPTR,#CurrentGroup_1
	MOV  	A,#0FFH
	MOVX 	@DPTR,A
; 	Get_MacAddr();
			; SOURCE LINE # 1183
	LCALL	Get_MacAddr
; 	cRemoteIDLETime = 500;
			; SOURCE LINE # 1184
	MOV  	DPTR,#cRemoteIDLETime
	MOV  	A,#01H
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#0F4H
	MOVX 	@DPTR,A
; 	fen_Duan = 0;  //分段
			; SOURCE LINE # 1185
	CLR  	A
	MOV  	DPTR,#fen_Duan
	MOVX 	@DPTR,A
; 	Set_Common_com_Data();	
			; SOURCE LINE # 1186
	LJMP 	Set_Common_com_Data
; END OF Power_On_Init

; }
; 
; uint8 single_RF_test=0;
; void main(void)  

	RSEG  ?PR?main?MAIN
main:
	USING	0
			; SOURCE LINE # 1190
; {
			; SOURCE LINE # 1191
; 	PALT1_INIT();  	//PALT1:(0x87):bit[]7:0]=PWM4_IO_EN,PWM3_IO_EN,PWM2_IO_EN,PWM1_IO_EN,PWM0_IO_EN,UART0_IO,SPI_IO,IIC_IO
			; SOURCE LINE # 1192
	CLR  	A
	MOV  	DPTR,#g_patchPALT1
	MOVX 	@DPTR,A
	MOV  	PALT1,A
; 	mcu_clk_inital();
			; SOURCE LINE # 1193
	LCALL	mcu_clk_inital
; 	gpio_init();
			; SOURCE LINE # 1194
	LCALL	gpio_init
;     WaitUs(500);
			; SOURCE LINE # 1195
	MOV  	R7,#0F4H
	MOV  	R6,#01H
	MOV  	R5,#00H
	MOV  	R4,#00H
	LCALL	_WaitUs
; 	
; 	Power_On_Init();   
			; SOURCE LINE # 1197
	LCALL	Power_On_Init
?C0124:
;     
; 	while(1)
			; SOURCE LINE # 1199
; 	{
			; SOURCE LINE # 1200
; 		EX5  = 1;								//RF interrupt
			; SOURCE LINE # 1201
	SETB 	EX5
; 		if(u10msFlag)
			; SOURCE LINE # 1202
	MOV  	DPTR,#u10msFlag
	MOVX 	A,@DPTR
	JZ   	?C0126
; 		{
			; SOURCE LINE # 1203
;             u10msFlag = 0;
			; SOURCE LINE # 1204
	CLR  	A
	MOVX 	@DPTR,A
;             Key_Scan();
			; SOURCE LINE # 1205
	LCALL	Key_Scan
;             Sys_SleepModeCheck();
			; SOURCE LINE # 1206
	LCALL	Sys_SleepModeCheck
; 		}
			; SOURCE LINE # 1207
?C0126:
; 		if(u2msFlag){	//每4ms执行一次
			; SOURCE LINE # 1208
	MOV  	DPTR,#u2msFlag
	MOVX 	A,@DPTR
	JZ   	?C0127
; 			u2msFlag = 0;
			; SOURCE LINE # 1209
	CLR  	A
	MOVX 	@DPTR,A
; 			if(adv_flag)
			; SOURCE LINE # 1210
	JNB  	adv_flag,?C0127
; 				TX_CMD_USE_BLE_mode();  //使用BLE模式发码		
			; SOURCE LINE # 1211
	LCALL	TX_CMD_USE_BLE_mode
; 		}
			; SOURCE LINE # 1212
?C0127:
; 		if(u20msFlag){
			; SOURCE LINE # 1213
	MOV  	DPTR,#u20msFlag
	MOVX 	A,@DPTR
	JZ   	?C0129
; 			u20msFlag = 0;
			; SOURCE LINE # 1214
	CLR  	A
	MOVX 	@DPTR,A
; 			if(adv_flag){
			; SOURCE LINE # 1215
	JNB  	adv_flag,?C0129
; 				Ble_Packet_Encode();
			; SOURCE LINE # 1216
	LCALL	Ble_Packet_Encode
; 			}
			; SOURCE LINE # 1217
; 		}
			; SOURCE LINE # 1218
?C0129:
; 		Sys_PowerDown();
			; SOURCE LINE # 1219
	LCALL	Sys_PowerDown
; 		Sys_PowerOn();
			; SOURCE LINE # 1220
	LCALL	Sys_PowerOn
; 		MCU_IDLE();
			; SOURCE LINE # 1221
	MOV  	PCON2,#01H
; 		_nop_();
			; SOURCE LINE # 1222
	NOP  	
; 		_nop_();
			; SOURCE LINE # 1223
	NOP  	
; 		_nop_();
			; SOURCE LINE # 1224
	NOP  	
; 		_nop_();
			; SOURCE LINE # 1225
	NOP  	
; 		_nop_();
			; SOURCE LINE # 1226
	NOP  	
; 		_nop_();
			; SOURCE LINE # 1227
	NOP  	
; 	}
			; SOURCE LINE # 1228
	SJMP 	?C0124
; END OF main

	END
